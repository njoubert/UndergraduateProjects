MMMM  M    M MMMMMMM MMMMM M     MMMMM     MMM    MMM   M   M     M MMMM  MMMM
M   M M    M      M      M M     M        M   M  M   M  M   M     M M     M   M
M   M M    M     M      M  M     M        M      M   M  M    M   M  M     M   M
M   M M    M    M      M   M     M        M      M   M  M    M   M  M     M   M
MMMM  M    M   M       M   M     MMMM      MMM   M   M  M    M   M  MMM   MMMM  
M     M    M   M      M    M     M            M  M   M  M     M M   M     M   M
M     M    M  M      M     M     M            M  M   M  M     M M   M     M   M
M     M    M M      M      M     M        M   M  M   M  M      M    M     M   M
M      MMMM  MMMMMM MMMMMM MMMMM MMMMM     MMM    MMM   MMMM   M    MMMM  M   M

		An Implementor's Guide to the solve Puzzle Solver
			*NIELS JOUBERT CS61B-BO*
			
						*** ============================ ***
						*** GENERAL ALGORITHM DESCRPITON ***
						***	============================ ***
						
A once sentence discription of the algorithm PuzzleSolver uses would be this:

Solver generates all the possible permutations of the names, colors and houses
mentioned in the assertions, filteres these permutations against the given assertions, 
and passes this to each question, where the information that equates across all the 
permutations of answers is used to construct a relevant answer.

A comprehensive description of solver is this:

solve.java
	attempts to read in a file, and if there is no file given, prints the instructions
	passes the file to solvePuzzle.
	
	solvepuzzle attempts to parse the file using parseFile()
	
	parseFile uses the PuzzleParser so generate all the assertions and all the questions
	classes corresponding to the information given in the file.
	
	PuzzleParser(Scanner input)
			PuzzleParser takes the given input and starts to read in sentences.
			PuzzleParser is only concerned with reading in a sentence, classifying
			it as a sentence or question, and sending this off to the Question or Assertion
			class to generate the appropriate Question or Assertion. This is then returned.
			PuzzleParsed *does* throw FileNotFoundExceptions and IllegalArgumentExceptions if
			things go wrong.
			
			Question.create(String) and Assertion.create(String)
				Both these methods follow the Command design pattern to find
				the appropriate question or assertion and return a new version
				containing the given information.
				Each question and assertion class, which represents one specific question
				or assertion, contains a parse method that takes a string, attempts to
				match it to its expected pattern, and returns a copy of itself
				if succeeded.
				
			All the assertions and questions have now been parsed and saved as two LinkedLists
			in the solve object. This is passed to the PuzzleSolver class.
			
			PuzzleSolver(LinkedList<Assertion> asserts)
				PuzzleSolver does the body of the work with assertions and permutations.
				
				extractKeywords is called, which extracts all the names, occupations and colors
				from the given assertions. Hewe we also check that no fields conflict
				i.e. using the same word as a color and an occupation.
				
				createAnonymous makes sure that we have the same amount of names, colors
				and occupations by filling in "#u" as the unknown token.
				
				createPossibilities sequences through the permutations generated by its call to
				PermutationPairs. each extracted permutation is associated with the names, 
				colors and occupations to generate a set of triples - {name, occupation, color} -
				that represents this one solution to the problem. The newly created set is now
				passed to each assertion, where the legality of the whole set is checked triple-by-triple
				against the assertions, and if any triple fail, the solution is illegal, and is not
				added to our set of answer sets.
				
			All the assertions are printed at this moment if no error was thrown by the
			PuzzleSolver.
			
			Each question is now printed
			This question is then answered - this is achieved by calling 
			PuzzleSolver.answer with the given question.
			
			PuzzleSolver.answer simply checks that the given question doesn't contain any
			mention of a name, occupation or color that we havent heard of, then
			calls the question's answer method and giving it the current set of answers.
			
			<Question>.answer(possibilitiesSet)
				The answers method first finds the triple that contains all the possible information
				that corresponds over all the generated answer set by calling findAnswer, supplying
				the field it wants and the value it is interested in for that field.
				Fields:
					0 = name
					1 = occupation
					2 = color
				
				The returned triple is now checked against what the question is asking, and
				the possible answer strings are hardcoded into each question class.
				
				
If the program made it to here, solve.exit(0) is called, which exits gracefully.
If at any point exceptions were thrown, solve.exit(1) is called, which
outputs an appropriate error message.


		
;; RANDOM IMPLEMENTATION DETAILS:
	In the questions and assertions, null is the default value for a name, color or occupation,
	meaning that it has not been set. On the other hand, in permutations, the string "#u" represents
	an unknown name, color or occupation.
				
			
						*** ===========================	***
						*** 		SOLVE				***
						***	===========================	***

;;SOLVE CLASS
	This is where everything starts from.
	the Main class of solve distunguishes between printing the instructions
	or reading in the file. Once that is established it calls the solvePuzzle method
	with an inputFile as srgument.
	
	SolvePuzzle(File inputFile)
		This is our method responsible for doing all of the "putting together".
		It first attempts to parse the input file, checking for errors.
		Once the inputFile is parsed, we attempt to:
			Create a new PuzzleSolver class which parses all the assertions into sets of possibilities.
				If this doesnt work an exception will be thrown
			Print all the assertions
			Checks whether the possible solution set is null. If it is - "That's impossible".
				Prints out every question, followed by its answer produced by the PuzzleSolver class.
			
	parseFile(File inputFile) throws FileNotFoundException, IllegalArgumentException
		generates a puzzleParser class.
		checks to see whether the file is legal
		reads in all the assertions
		checks for an error
		reads in all the questions
		checks for an error.
		===> all of this is accomplished with the methods of the PuzzleParser class.
		
	printInstructions()
		Attempts to read in and print out the standard help file. If it cant find the help file
		it prints out a generic help message.
		
	printError()
		Attempts to read in and print out the standard error file. If it cant find the error file
		it prints out a generic error message.
	
	
	EXITING FROM THE PROGRAM && SHOWING ERRORS:
	
		solve.exit(int code) gives a way to exit the program with the
		appropriate error messages. If this is called with a code other than one
		
		
;;PUZZLESOLVER CLASS
	The PuzzleSolver class is responsible for solving the puzzle according to our assertions, 
	and retain a solution that each question can use to determine whether an answer has been 
	computed for the specific question.
	
	The primary duty of a Puzzlesolver is to generate the set of possible answer sets, with each answer
	set consisting of a two-dimensional array of name-occupation-color triples. In other words, it takes
	a list of assertions, stores this, and through permutation and filtering, builds possible answers.
	These possible answers can be matched against any question through the answer(Question) method.
	
	Constructor:
	
		PuzzleSolver(LinkedList<Assertion> asserts)
			Almost all the functionality of the class is used in the constructor.
			It consists of three major steps:
			- extracting keywords - this builds the lists of names, occupations an colors
			- create anonymous - this ensures that you have the same amount of names/occupations/colors
			- create possibilities - this associates names, occupations and colors with permutations, 
				matches it against the given assertions, and builds the list of sets of triples, each
				one representing one possible solution to the puzzle. It also only adds a possibility to
				the list if there is none that corresponds to it. The questions use this to find
				information to answer their question.
				
	METHODS:
		
		String answer (Question query)
	  		 The answer to QUERY.  Returns null if the assertions used to 
			 construct THIS are inconsistent. This also makes sure
			 that the question doesn't mention something we don't know about, using crossCheck.

		extractKeywords() 
			This method simply asks every assertion for its stored name, occupation and color,
			ensures that the data does not conflict between lists, and uses addUniqueString to
			add it to the list of known names, occupations and colors.
			
		createAnonymous()
			finds the maximum length of names, colors or occupations, and creates
			anonymous fields for the names, colors and occupations so that they are
			all this maximum length long.
			
		createPossibilities()
			Fills up the list of possibilities using the permutation generator
			and filters it against all the assertions.
	  		this depends on the names / occupations / colors being set
			
		void addUniqueString(List<String> ls, String s)
			adds the element only to the list if the element is unique. 
			Does NOT add null!
			
		 String[][] associatePermsWithStrings(int[][] PermPair)
			 This method will take in a permutation pair and match
			 it up against the stored names, colors, occupations, and return
			 an array of Strings, with n arrays each consisting of a name, occupation, color triple.
			 nulls are translated to #u.
			 
		 private boolean crossCheck(Question query)
			 checks whether the given question conforms to the known names/occupations/colors,
			 and returns false if it doesn't.
  
			 
		 boolean isPossible() 
		 	after generating the possibilities, this returns a true or false, with false corresponding
			to the LinkedList answers being empty, signifying that all none of the possibility sets
			passed the assertions.
			 
		 
						*** ===========================	***
						*** 		PARSERS				***
						***	===========================	***

;;PUZZLEPARSER CLASS
The puzzleparser class takes in a Scanner and parses this into the appropriate sentences
as either an assertion or question depending on their end literal:
	"."	= assertion
	"?" = question
The puzzleparser class does not allow a mix of these two, and strictly parses input
only if the assertions come before the questions. If an assertion follows a question,
the error() method will return true while all other methods concerned with parsing will
refuse to give results.

IMPORTANT NOTE: This class only classifies according to what the sentence ends in, thus
it will return true for hasAssertion or hasQuestion even if the sentence does NOT conform
to the standards set in the guidles of what a proper assertion or question is. It is up
to the Assertion and Question classes to handle incorrect input of this type, and this
will be caught in the nextAssertion and nextQuestion method.

The body of the work is done in the private method "readAndClassifyNextSentence".
	This will attempt to extract the next sentence
	classify it according to end literal as a question or assertion.
	it will set the appropriate field - hasAssertion or hasQuestion - accordingly.
	After parsing the sentence it will check those fields to see whether the input is legal.
	That is, if the hasQuestion flag is true and hasAssertion flag is false, and it 
	reads an assertion, it will ser the parseError flag to true and stop all activity.
	On the other hand, ifthe hasAssertion flag is true and a question is read, 
	the hasQuestion flag is set, and parsing continues.
	When both hasQuestion and hasAssertion is false and there is no error - error() returns false,
	then the whole file has been parsed.
	
The parsed sentences are accessible one by one by using hasAssertion(), nextAssertion()
and hasQuestion(), nextQuestion() and errors can be checked through error().

CONSTRUCTOR:
	
	PuzzleParser(Scanner input)
		This wil create a PuzzleParser class that will use the given Scanner to read from.
	
METHODS:

	boolean hasAssertion(), hasQuestion()
		These methods indicate whether the current sentence is an assertion or question.
		once hasQuestion becomes true as the input is sequentially read, hasAssertion is never
		allowed to be true again, and this is checked inside the PuzzleParser class.
		
	Assertion nextAssertion() throws IllegalStateException
		This method will parse the next sentence in the Scanner and return an assertion object
		representing this sentence. This is partly accomplished using the create(String) method
		of the Assertion class. This method depends on the fact that hasAssertion() returns true.
		This method will also process the next sentence in line in the scanner once it is called
		to process the currently stored sentence. If the input failed to match any of the given
		patterns for specific Assertion types, the error thrown by the Assertion class will be caught
		and the error flag set to true.
		
	Question nextQuestion() throws IllegalStateException
		This method will parse the next sentence in the Scanner and return a question object
		representing this sentence. This is accomplished using the create(String) method of the
		Question class. This method depends on the fact that hasQuestion() returns true.
		This method will also process the next sentence in line in the scanner once it is called
		to process the currently stored sentence. If the input failed to match any of the given
		patterns for specific Question types, the error thrown by the Question class will be caught
		and the error flag set to true.
		
						
				
PRIVATE METHODS:

	readAndClassifyNextSentence()
		This method depends on the fact that myInput has a scanner, and myPattern has a compiled
		pattern to match.
		
		
;;LINEPARSER CLASS
The Lineparser class is a simple class that parses a given string according to a given pattern.
The lineparser class also checks for keywords in the text, which causes a return value of null - 
it is as if the keywords are removed from the matched strings.
The LineParser class can either be used through its static methods to do easy parsing, especially
useful for the Question objects, or can be instantiated into parsers that gives more flexibility
in the number of groups to be matched. It always checks for the hard-coded illegal keywords, and can
be supplied with arguments for additional illegal keywords if so desired.

Static Methods:
	
	String extractMatch(String uncompiledPattern, String unparsedString)
		this will attempt to extract the first group of the pattern from the given string.
		If there is no match, it returns null.
		If there is a match but it violates the program specifications, 
		it returns null.
		
Constructors:
	
	LineParser(String uncompiledPattern, String unparsedString)
		compiles the given pattern and attempts to match it against the given string.
		
Methods:

	boolean didMatch()
		returns true if the given pattern matched the given string
		
	String extractGroup (int Group)
		returns the given group's matched string or null if the given group was an illegal keyword.


						*** ===========================	***
						*** 		QUESTIONS			***
						***	===========================	***
			
;;QUESTION CLASS
The Question class is a abstract class representing the questions parsed from the input file. 
This question class is the umbrella class for every type of question our program understands.
The 9 types of questions that extend this class is:
	1.a) QWhatDoYouKnowAboutName
	1.b) QWhatDoYouKnowAboutTheOccupation
	2.) QWhatDoYouKnowAboutTheColorHouse
	3.) QWhoIsTheOccupation
	4.) QWhoLivesInTheColorHouse
	5.) QWhatDoesTheOccupantOfTheColorHouseDo
	6.) QWhatDoesNameDo
	7.a) QWhereDoesNameLive
	7.b) QWhereDoesTheOccupationLive
	
	The question class uses the global standard of setting "#u" as the value of
	a string for which it has no information.

The umbrella Question class creates these classes and wraps them in itself. 
In other words, the Question class is responsible for taking a Question string, 
parsing this, and creating the specialized object of one of the given types to represent
this question.
This question object can take in a name, occupation, house-color triple and answer it.


The question class has these methods:
	
	CONCRETE:
	
	Question create(String unparsedQuestionString) throws IllegalArgumentException
		returns a specific question type (a subtype of the generic Question class)
		that represents the given question string.
		This uses the Parse method of the cildren to generate this specific type.
		If the input matches none of the specified questions, it throws an IllegalArgumentException
		
	String toString()
		returns the stored question in the proper format.
		
	String getName(), getOccupation(), getColor()
		returns the name, occupation or color this question deals with
		
 	
		
	ABSTRACT:
	
	Question parse(String unparsedQuestionString)
		This method must be implemented in each of the subtypes of Question.
		It returns a question of the specific type if the unparsedQuestionString applies to it
		or it returns null. This method works strongly with the Constructor of each subclass.
		
	String answer(LinkedList<String[][]> possibilitiesSet)
		answer takes the list of possibilities and uses the static method findAnswer()
		to reduce the set of possibilities to a single pair of all the information we
		have concerning the field and value the specific question is concerned with.
		
	String[] findAnswer(int field, String value, LinkedList<String[][]> possibleS)
		This is the answer generator.
		It takes a set of possibilities allowed by the assertions.
		It finds the requested triple in each possibility set (represented as an array of triples)
		and compiles this into the best possible info that can be extracted
		from the triples that satisfy the requirements in the possible set.
		
		@param field - an integer: 0 == name, 1 == occupation, 2 == color - the field to extract.
		@param value - a String - the value you want the specified field to be.
		@param possibleS - a LinkedList of possibilities, each represented by a 2D string of triples.
		@return the tripe that has the most information we could find.
   
	String[] extractTriple(int field, String value, String[][] answerS)
		Takes in an answer set - a 2D array of variable length consisting of triples.
		Each triple consists of {name, occupation, color}. 
		Find the triple that has the given value in the given field.
		Fields are:
		0 = name
		1 = occupation
		2 = color
		
;;CHILDREN OF THE QUESTION CLASS - the 9 specific question types.
Each specific question subtype has these methods:

	Constructor()
		returns an object of the specific question type with no information
	
	Constructor(String name, String occupation, String color)
		returns an object of the specific question type with the specific info set;
		This method is called by the parse method if the given unparsedQuestionString matches the specific
		question type. This constructor is then called to create the question object.
		
	Question parse(String unparsedQuestionString)
		This will create the current type of object if the unparsedQuestionString matches the
		type of question. Else it will return null.
		This method relies on the LineParser class.
		
	String answer(String name, String occupation, String color)
		Iff the fact that NAME is the OCCUPATION and lives in the COLOR house
		is enough information to answer THIS question,
		then return the appropriately formatted answer.  Otherwise return
		null. For example, if THIS represents "Who is the carpenter?", then
			answer ("Tom", "carpenter", "white")
				=> "Tom is the carpenter."
			answer ("Tom", "plumber", "red")
				=> null
			answer (null, "carpenter", "red")
				=> "I don't know."
	   (where null here designates an unknown name, not equal to any non-null String.)
	   
	   
	  					*** ===========================	***
						*** 		ASSERTIONS			***
						***	===========================	***
						
;;ASSERTION CLASS
The Assertion class represents a single sentence assertion. It accomplishes this through
having a child class for every type of assertion is understands. The assertion class
can parse a sentence containing an assertion into one of its specialized assertion subclasses
using its create method. An assertion can also verify a given name-occupation-house triple
against its given information.
The understood child classes representing specialized assertions are:
	1.a) ANameLivesInHouse
	1.b) ANameDoesNotLiveInHouse
	2.a) AOccupationLivesInHouse
	2.b) AOccupationDoesNotLiveInHouse
	3.a) ANameIsOccupation
	3.b) ANameIsNotOccupation
	4.) ANameLivesAroundHere
	5.) AOccupationLivesAroundHere
	6.) AHouse
	
	
	The assertion class uses null as the value of a variable for which it has no information. 
	
The Assertion class also serves as the wrapper class for any of its child assertions.
These are its methods:

	CONCRETE:
	
	Assertion create(String unparsedAssertionString) throws IllegalArgumentException
		returns a specific assertion object representing the assertion given in the unparsed string.
		It uses the parse command of the child classes to both find the right type of assertion
			and to parse the given string.
		If none of the known assertion classes match the string, it throws an exception.
		It finds the list of known Assertions from the constant field assertionTypes declared in the class.
		
	String getName(), getOccupation(), getColor()
		returns the stored NAme, Occupation or Color, or returns null if the assertion did not
		contain information about the asked field.
	
	String toString()
		returns a string representation of the given assertion. This is correctly whitespaced!
		
	ABSTRACT:
	
	boolean allows(String name, String occupation, String color)
		This method checks the argument triple against the assertion information, and
		returns true if the given information is compatible with the assertion
		or returns false if the given information violates the assertion.
		
	Assertion parse(String unparsedAssertionString)
		returns a new object of the specific implemented Assertion class if the given unparsedAssertionString
		matches the object's represented assertion type.
		
	
;;CHILDREN OF THE ASSERTION CLASS
For every type of assertion there is a special subclass to represent it. This subclass is instantiated
when the Question class in created to be put into the array of known subclasses. 
Each assertion class has 2 constructors and 2 public methods:

	public Constructor()
		This creates a generic object of this type without any data.
		
	public Constructor(String name, String organization, String color)
		This creates an object of this type with the given information, usually
		parsed from the parse method of this object.
		
	public Assertion parse(String unparsedAssertionString)
		this method attempts to match up the given string to this object's expected 
		assertion string type. It does this by using the LineParser class to match a fixed
		regular expression against the incoming string.
		If the string matches this type of assertion object, a new assertion object is created, 
		else null is returned.
		
	public boolean allows(String name, String occupation, String color)
		  True iff the alleged fact that NAME is the OCCUPATION and lives in
		  the COLOR house is not contradicted by THIS assertion.  Any one
		  of NAME, OCCUPATION, or COLOR may be null, indicating an unknown
		  value that does not match any non-null String.
		  
		  				*** ===========================	***
						*** 		PERMUTATIONS		***
						***	===========================	***
						
		To generate the set of possible answers in this program, we use a permutation generator
		wrapped into a permutationpairs generator.
		
;;PERMUTATIONS GENERATOR

The permutations generator generates permutations of numbers between 0 and N.
CONSTRUCTOR:

	PermutationsGenerator(int n)
		where n is the upper bound of the numbers to generate permutations from.
		
METHODS:
	
	getNext()
		The most used method of any of these objects - it returns the next permutation.
		It stores this permutation in a private field to use to generate the next permutation from.
		It returns a integer array of the length of elements ( from 0 to n-1 ) with a permutation of
		that numbers.
		
	getNumLeft()
		will return the number of permutations left.
		
	getTotal()
		equivalent to calling n!, this returns the total number of permutations.
		
	hasMore()
		will return true as long as more permutations can be generated.
	
	reset()
		resets permutationgenerator to again start generating from the first permutation
		
;;PERMUTATION PAIRS GENERATOR
	This class uses the PermutationsGenerator class to generate a pair of permutations of a given range 
	of numbers (0, n). The pairs are given out as a 2 element array, each element containing an array of
	permutations. This is a keystone of the project. Seeing that it so strongly 
	rests on the permutations generator, its methods will often be a weird wrapper
	for the marchers.
	
CONSTRUCTOR:
	PermutationPairs(int n)
		N is the upper bound of the range of numbers to permute - perm E (0, n)
		my constructor simply initializes two new PermutationGenerators to accomplish this deal.
		
METHODS:
	hasNextPair()
		simply checks to see whether the underlying two permutationgenerators still has pairs left.
		
	getLastPAir()
		returns the last returned pair - can return the same pair many times between calls to next();
		
	int[][] nextPair()
		the most used, big and important method in this class. This will sequentiall return sequences
		of pairs of permutations. It does this by repeatedly iterating through the innerPerms 
		permutation generator, associating its output with the current outerPerms output, until
		inner is empty and outer moves one permutation up, continuing this looping of a loop
		until all the possibilities have been generator.
		PLEASE use the hasNextPair method of your profram to chack whether you can keep on calling this.
		

		  
		  				*** ===========================	***
						*** 		ERROR TESTING		***
						***	===========================	***
								JUnit Testing
								
								

		
