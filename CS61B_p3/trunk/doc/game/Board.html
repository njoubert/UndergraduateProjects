<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Sat May 06 16:50:08 PDT 2006 -->
<TITLE>
Board
</TITLE>

<META NAME="keywords" CONTENT="game.Board class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Board";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Board.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../game/AutoCommand.html" title="class in game"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../game/BoardTest.html" title="class in game"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?game/Board.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Board.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
game</FONT>
<BR>
Class Board</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>game.Board</B>
</PRE>
<HR>
<DL>
<DT><PRE> class <B>Board</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
A Jump61b board state.  
 
 
 <H3>THE BOARD</H3>
 <P>
 A board is a grid of N rows and N columns, 
 where (1 <= r, c <= N)
 
 To represent the board we need some data structure that holds
 N*N points, each one with a color and number of dots associated.
 The number of dots vary between one and five (although during operation
 this might be exceeded in the middle of movement procedures), and 
 colors (as represented in the Color enumeration) as White, Blue and Red.
 
 <P>The most obvious choices for representing this structure are
 either an OO-approach, using an object for each square and
 building a "grid" of these objects. By using fake nodes
 as the borders of the board, all squares will have
 4 neighbors (the borders and corners has some virtual ones)
 and, by using return values correctly and being careful in
 writing base cases in the nodes, we can build this.
 <BR><u>The advantage of this</u> is the clean code (especially the 
 jumping of spots) and the object-orientated approach.
 <br><u>The disadvantage of this</u> is the space inefficiency over some
 other methods and the limitations of Java's non-tail-recursive implementation.
 I found that my OO-approach was limited to a small number of jumps, insufficient
 for the size of boards I needed, thus I abandoned this approach (its still some
 separate branch in my CVS repository if i need it again hehehe).
 <P>A N-by-N array can also be used to represent the matrix.
 By building a data abstraction layer for the squares that
 encodes squares as byte values, we can use this array
 of rows and columns exactly like a board through some
 streamlined getter and setter methods.
 <BR><u>The advantage of an array</u> to represent this matrix, with some smart math and bitshifting
 behind it, is its small size, incredibly fast speed if we stay away from recursion, 
 and it is fun to code, seeing that I enjoy incorporating some math into my programs.
 This also allows for some creative encoding schemes for the
 values of squares.
 </P>
 <P>Needless to say, I chose the latter.
 The whole board is represented as an N by N array of
 bytes, where the first N array represents the rows
 and the second R array represents the columns in
 each row.
 To retrieve a certain row and certain column from
 the board you simply use
 myBoard[r-1][c-1]
 
 The reason for the negatives is that the array reaches
 from 0 to (n-1) while input ranges from 1 to n.
 
 <BR>I streamline access to the board through getter and setter procedures
 (getSquareAt,setSquareAt,incrementSquareAt,decrementSquareAt, withinBounds) which is used by
 all the other methods in this class to access the board.
 </P>
 <P><H2>DATA ABSTRACTIONS IN THE BOARD CLASS</H2>
 <P>There are a couple of data abstractions in this class:
 <ul><li>Square - a byte representation of a color, spots value.</li>
 <li>Position - a int array representing a {r,c} value</li>
 <li>Board - a byte 2D array representing a board as byte[r][c] values</li>
 </ul>
 <BR>==================== BOARD DATA ABSTRACTION ==================== 
 <BR>These methods end with "SquareAt" seeing that we
 work with the square at a certain position on
 the board.
 <BR>==================== POSITION ====================
 <BR>Uses the Position Data Abstraction:
 A positon is represented by a legnth 2 array of integers,
 with the first value representing the row number, and the
 second value representing the column number.
 <BR>==================== SQUARE DATA ABSTRACTION ==================== 
 <BR>All methods contain "ASquare"
 seeing that these methods work with a single square as
 both input and output.
 
 
 <H3>EACH SQUARE OF THE BOARD</H3>
 <P>
 A byte represents one square, encoding a color and number of spots.
 The byte value encodes values as this:
 
 <BR>byte value = ((color.ordinal() << 5) ^ (spots - 1));<BR>
 
 Thus to decode the byte values:
 
 <BR>color = (square >>> 5)
 <BR>spot nr = (square & 0x1f) + 1
 <BR>
 The big idea here is to compress the color value (by its ordinal value)
 and the number of spots into a single byte.
 The reasoning behind the minus one, plus one here is to 
 dissuade from the necessity to "instantiate" the new array
 into certain values beforehand. By default any zero value
 is decoded as a "White, 1 spot" value.
 
 <BR>Access to all of this is given through getter and ctreator procedures\
 (getASquareSpots, getASquareColor, makeASquare)
 </P>
 <H3>LEGAL MOVES</H3>
 <P>
 A move can only be legal if there are any legal moves on the board,
 and that the specific point is a legal square.
 Adding to a square is a legal move if the square is
 not the color of the opponent. 
 
 In describing legal moves and moves in general there are some issues
 that must be addressed. If you have a legal move, it means that
 there is still a square that is your color and a square that is your
 opponent's color. Thus, if all the squares are the same color it is illegal for both.
 You can traverse the whole board to check this, but it might not be the
 best approach.
 <P> I hold an invatriant of the total number of squares of each color
 on the board, so thagt at any moment i have a counter value of the number
 of white, red and blue squares, where they always add up to the total number
 of squares on the board. This stremlines isLegal and getWinner and makes it possible to
 check at every iteration of the spot jumping procedures whether we have a winner
 yet or not.
 </P>
 <H3>ADDING SPOTS TO A BLOCK</H3>
 <P>
 We assume that the block is a legal place.
 The first step is to add a spot and color the block
 the color of the current player.
 This is done through the encoding algorithm described above.
 Now we need to start jumping spots...
 </P>
 
 <H3>SPOT MOVEMENT</H3>
 <P>
 Once a spot has been added, spots needs to be 
 distributed so that the equilibrium state of the
 board is again reached.
 This simple rule is that no square can have more
 spots than neighbors, if it has, the spots
 is distributed to these nieghbors, one per neighbor.
 There are three cases that needs to be handled in 
 this situation - inner squares, border squares and
 corner squares. These can all be handled
 simply by looking at each neighbor one by one, and if
 there is one, we take the appropriate action to increment it
 and decrement the current spot. 
 <br>This is the algorithm for moving spots:
 
 <br>1) increment the current spot. Change the color invariant accordingly.
 <br>2) Add it to the queue of spots that has been changed.
 <br>3) Check whether it is overfull, if it is:
<br> 3a) check the type of spot, and increment/decrement the spots accordingly (keeping the color invariant)
 <br>4) Repeat the procedure with all the affected squares now in the queue.

 </P>
 <H3>COLOR VALUES INVARIANT</H3>
 <P>To keep track of the amount of squares of each color on the board,
 we keep a loop invariant of the amount of colors on the board:
 <br><b># Red Squares + # Blue Squares + # White Squares = size() * size()</b>
 <br>This needs to upheld by the spot adding/jumping procedure.
 <br>These values are all stored in an array that stores the amount of squares
 associated with a specific value in the indice corresponding to the ordinal value of
 that color. The array is called <b>colorInvariant[]</b>  
 Keeping the loop invariant is done mainly in the jumpNeighbors procedure. Every time
 we change a square, we decrement the total number of spots with its original
 color and increate the total number of squares of its new color.
 AddSpot also contains this procedure for the moment we add a spot to the board.
 <br>This allows us to stop the jumping the moment one player wins by owning the whole board.
 
 </P>
 <H3>ERROR HANDLING</H3>
 <P>
 If any command gets parameters that does not follow its expected valued,
 it throws an IllegalArgumentException as expected.
 <BR>The assertWithinBounds(r,c) method checks to see whether the given row-col value
 is within the boundaries of the board, and if not it throws an IllegalArgumentException.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#colorInvariant">colorInvariant</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The color invariant storage space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;byte[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#myBoard">myBoard</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Board represented as an 2D array of position data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#n">n</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of rows or columns on the board</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../game/Board.html#Board(game.Board)">Board</A></B>(<A HREF="../game/Board.html" title="class in game">Board</A>&nbsp;board0)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A board whose initial contents are copied from BOARD0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../game/Board.html#Board(int)">Board</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An NxN board in initial configuration.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#addSpot(game.Color, int, int)">addSpot</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player,
        int&nbsp;r,
        int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a spot from PLAYER at row R, column C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#assertWithinBounds(int, int)">assertWithinBounds</A></B>(int&nbsp;r,
                   int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the given position is within the boundaries
 of the current board.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../game/Color.html" title="enum in game">Color</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#color(int, int)">color</A></B>(int&nbsp;r,
      int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The color of the square at row R, column C, 1 <= R, C <= size().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#decreaseAndJump(int[], java.util.ArrayList, game.Color)">decreaseAndJump</A></B>(int[]&nbsp;pos,
                java.util.ArrayList&lt;int[]&gt;&nbsp;queue,
                <A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used by addSpot to decrease the spots at and twiddle the spots around
 a certain position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#decrementSquareAt(int, int, int)">decrementSquareAt</A></B>(int&nbsp;r,
                  int&nbsp;c,
                  int&nbsp;amount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrements the amount of spots of the square at the given row, col position,
 with the given amount.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;<A HREF="../game/Color.html" title="enum in game">Color</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#getASquareColor(byte)">getASquareColor</A></B>(byte&nbsp;square)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#getASquareSpots(byte)">getASquareSpots</A></B>(byte&nbsp;square)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#getSquareAt(int, int)">getSquareAt</A></B>(int&nbsp;r,
            int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extracts the square with the given row, column position
 from the board.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;<A HREF="../game/Color.html" title="enum in game">Color</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#getWinner(game.Color)">getWinner</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;currentPlayer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The winner (if any) of the current position, if the game is over,
  and otherwise null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#hasSquares(game.Color)">hasSquares</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#incrementSquareAt(game.Color, int, int)">incrementSquareAt</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;color,
                  int&nbsp;r,
                  int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increments the amount of spots of the square at the given row, col position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#isFull()">isFull</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This physically counts every square to check the board - almost "backup check" for the color invariant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#isLegal(game.Color)">isLegal</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True iff player with given Color is allowed to make some move at this
  point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#isLegal(game.Color, int, int)">isLegal</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player,
        int&nbsp;r,
        int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True iff it is currently legal for PLAYER to add a spot to square 
  at row R, column C.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#isOverfull(int[])">isOverfull</A></B>(int[]&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks to see whether the given square is overfull.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#makeASquare(game.Color, int)">makeASquare</A></B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;color,
            int&nbsp;spots)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a square according to the given paramteres</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#setSquareAt(byte, int, int)">setSquareAt</A></B>(byte&nbsp;square,
            int&nbsp;r,
            int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of the given position on the board to the given square.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of rows and of columns of THIS.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#spots(int, int)">spots</A></B>(int&nbsp;r,
      int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of spots in the square at row R, column C, 
  1 <= R, C <= size ().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#toDisplayString()">toDisplayString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An external rendition of THIS, suitable for human-readable textual 
  display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../game/Board.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The dumped representation of THIS.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="colorInvariant"><!-- --></A><H3>
colorInvariant</H3>
<PRE>
private int[] <B>colorInvariant</B></PRE>
<DL>
<DD>The color invariant storage space.
  Stores the invariant: redSquares + blueSquares + whiteSquares = size() * size()
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="myBoard"><!-- --></A><H3>
myBoard</H3>
<PRE>
private byte[][] <B>myBoard</B></PRE>
<DL>
<DD>The Board represented as an 2D array of position data.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="n"><!-- --></A><H3>
n</H3>
<PRE>
private int <B>n</B></PRE>
<DL>
<DD>The number of rows or columns on the board
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Board(game.Board)"><!-- --></A><H3>
Board</H3>
<PRE>
<B>Board</B>(<A HREF="../game/Board.html" title="class in game">Board</A>&nbsp;board0)</PRE>
<DL>
<DD>A board whose initial contents are copied from BOARD0.
<P>
</DL>
<HR>

<A NAME="Board(int)"><!-- --></A><H3>
Board</H3>
<PRE>
<B>Board</B>(int&nbsp;N)</PRE>
<DL>
<DD>An NxN board in initial configuration.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addSpot(game.Color, int, int)"><!-- --></A><H3>
addSpot</H3>
<PRE>
void <B>addSpot</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player,
             int&nbsp;r,
             int&nbsp;c)</PRE>
<DL>
<DD>Add a spot from PLAYER at row R, column C.  Assumes 
  isLegal (player, r, c).
  <BR>A simple procedure of adding to a square, then iterating through
  each affected square, checking whether it is overfull - if so, we use
  the decreaseAndJump method to redistribute its spots.
  We also keep the color invariant of the board:
  # Red Squares + # Blue Squares + # White Squares = size() * size();
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="assertWithinBounds(int, int)"><!-- --></A><H3>
assertWithinBounds</H3>
<PRE>
private boolean <B>assertWithinBounds</B>(int&nbsp;r,
                                   int&nbsp;c)</PRE>
<DL>
<DD>Checks whether the given position is within the boundaries
 of the current board. Throws an IllegalArgumentException with an appropriate
 message if the given point is not inside the size of the board.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - <DD><CODE>c</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="color(int, int)"><!-- --></A><H3>
color</H3>
<PRE>
<A HREF="../game/Color.html" title="enum in game">Color</A> <B>color</B>(int&nbsp;r,
            int&nbsp;c)</PRE>
<DL>
<DD>The color of the square at row R, column C, 1 <= R, C <= size(). 
 Checks whether the input lies within the boundaries, 
  then use the described algorithm to extract the color
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="decreaseAndJump(int[], java.util.ArrayList, game.Color)"><!-- --></A><H3>
decreaseAndJump</H3>
<PRE>
private void <B>decreaseAndJump</B>(int[]&nbsp;pos,
                             java.util.ArrayList&lt;int[]&gt;&nbsp;queue,
                             <A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player)</PRE>
<DL>
<DD>Used by addSpot to decrease the spots at and twiddle the spots around
 a certain position. This is achieved by looking at each neighbor and
 adding a spot to it if there is a neighbor, and keeping track of the amount
 of neighbors you've given spots to, and finally decrementing the current
 spot by this value. 
 Keeping the loop invariant is done mainly in this procedure. Every time
 we change a spot, we decrement the total number of spots with its original
 color and increate the total number of spots of its new color.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pos</CODE> - - a position array {R,C} that is to be jumped from.<DD><CODE>queue</CODE> - - the queue which the loop is using to jump all the spots with.<DD><CODE>player</CODE> - - the color we are jumping with.</DL>
</DD>
</DL>
<HR>

<A NAME="decrementSquareAt(int, int, int)"><!-- --></A><H3>
decrementSquareAt</H3>
<PRE>
private void <B>decrementSquareAt</B>(int&nbsp;r,
                               int&nbsp;c,
                               int&nbsp;amount)</PRE>
<DL>
<DD>Decrements the amount of spots of the square at the given row, col position,
 with the given amount.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - - the row value, 1 <= r <= n<DD><CODE>c</CODE> - - the col value, 1 <= c <= n<DD><CODE>amount</CODE> - - the amount with which to decrese the square</DL>
</DD>
</DL>
<HR>

<A NAME="getASquareColor(byte)"><!-- --></A><H3>
getASquareColor</H3>
<PRE>
private static <A HREF="../game/Color.html" title="enum in game">Color</A> <B>getASquareColor</B>(byte&nbsp;square)</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>The color of the square encoded in the given square byte.</DL>
</DD>
</DL>
<HR>

<A NAME="getASquareSpots(byte)"><!-- --></A><H3>
getASquareSpots</H3>
<PRE>
private static int <B>getASquareSpots</B>(byte&nbsp;square)</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>The amount of spots encoded in the given square byte.</DL>
</DD>
</DL>
<HR>

<A NAME="getSquareAt(int, int)"><!-- --></A><H3>
getSquareAt</H3>
<PRE>
private byte <B>getSquareAt</B>(int&nbsp;r,
                         int&nbsp;c)</PRE>
<DL>
<DD>Extracts the square with the given row, column position
 from the board.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the byte square representation as described by the Square Data Abstraction</DL>
</DD>
</DL>
<HR>

<A NAME="getWinner(game.Color)"><!-- --></A><H3>
getWinner</H3>
<PRE>
<A HREF="../game/Color.html" title="enum in game">Color</A> <B>getWinner</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;currentPlayer)</PRE>
<DL>
<DD>The winner (if any) of the current position, if the game is over,
  and otherwise null. Simply checks the color invariant to
  see whether there the whole board is only one color, and
  if it is, that person is returned as the winner, else
  a null value is returned.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasSquares(game.Color)"><!-- --></A><H3>
hasSquares</H3>
<PRE>
int <B>hasSquares</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="incrementSquareAt(game.Color, int, int)"><!-- --></A><H3>
incrementSquareAt</H3>
<PRE>
private int[] <B>incrementSquareAt</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;color,
                                int&nbsp;r,
                                int&nbsp;c)</PRE>
<DL>
<DD>Increments the amount of spots of the square at the given row, col position.
 This also involves changing it to the given color value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>color</CODE> - - the color of the square after incrementing it.<DD><CODE>r</CODE> - - the row value, 1 <= r <= n<DD><CODE>c</CODE> - - the col value, 1 <= c <= n
<DT><B>Returns:</B><DD>position - a 2-length array representing the {row, col} position.</DL>
</DD>
</DL>
<HR>

<A NAME="isFull()"><!-- --></A><H3>
isFull</H3>
<PRE>
boolean <B>isFull</B>()</PRE>
<DL>
<DD>This physically counts every square to check the board - almost "backup check" for the color invariant.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True iff the board has no more space for any squares.</DL>
</DD>
</DL>
<HR>

<A NAME="isLegal(game.Color)"><!-- --></A><H3>
isLegal</H3>
<PRE>
boolean <B>isLegal</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player)</PRE>
<DL>
<DD>True iff player with given Color is allowed to make some move at this
  point.
  This is only satisfied when the current player does not own the board
  or the current player's opponent does not own the board.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isLegal(game.Color, int, int)"><!-- --></A><H3>
isLegal</H3>
<PRE>
boolean <B>isLegal</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;player,
                int&nbsp;r,
                int&nbsp;c)</PRE>
<DL>
<DD>True iff it is currently legal for PLAYER to add a spot to square 
  at row R, column C.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isOverfull(int[])"><!-- --></A><H3>
isOverfull</H3>
<PRE>
private boolean <B>isOverfull</B>(int[]&nbsp;pos)</PRE>
<DL>
<DD>Checks to see whether the given square is overfull.
 This is accomplished by calculating the maximum number of spots
 allowed at a given position, and checking whether the given position
 exceeds this number.
 <br>We know that all squares can keep 2 spots at least, so we set this
 as a starting value for the maximum amount of spots. We then check whether
 its in the top or bottom row, if not, increase this value by one. We do
 the same for the left/right row.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pos</CODE> - - a position array of the form {R,C}
<DT><B>Returns:</B><DD>true if the given spot is overfull.</DL>
</DD>
</DL>
<HR>

<A NAME="makeASquare(game.Color, int)"><!-- --></A><H3>
makeASquare</H3>
<PRE>
private static byte <B>makeASquare</B>(<A HREF="../game/Color.html" title="enum in game">Color</A>&nbsp;color,
                                int&nbsp;spots)</PRE>
<DL>
<DD>Creates a square according to the given paramteres
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>color</CODE> - - The color that will be encoded onto the square.<DD><CODE>spots</CODE> - - The amount of spots to be encoded on the square.
<DT><B>Returns:</B><DD>The paramteres encoded into a byte square value.</DL>
</DD>
</DL>
<HR>

<A NAME="setSquareAt(byte, int, int)"><!-- --></A><H3>
setSquareAt</H3>
<PRE>
private void <B>setSquareAt</B>(byte&nbsp;square,
                         int&nbsp;r,
                         int&nbsp;c)</PRE>
<DL>
<DD>Sets the value of the given position on the board to the given square.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>square</CODE> - - the byte square representation as described by the Square Data Abstraction<DD><CODE>r</CODE> - - the row value, 1 <= r <= n<DD><CODE>c</CODE> - - the col value, 1 <= c <= n</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
int <B>size</B>()</PRE>
<DL>
<DD>The number of rows and of columns of THIS.
 i.e. 1 <= row <= size()
 and the same goes for columns
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="spots(int, int)"><!-- --></A><H3>
spots</H3>
<PRE>
int <B>spots</B>(int&nbsp;r,
          int&nbsp;c)</PRE>
<DL>
<DD>The number of spots in the square at row R, column C, 
  1 <= R, C <= size (). Checks whether the input lies within the boundaries, 
  then use the described algorithm to extract the spot number.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toDisplayString()"><!-- --></A><H3>
toDisplayString</H3>
<PRE>
public java.lang.String <B>toDisplayString</B>()</PRE>
<DL>
<DD>An external rendition of THIS, suitable for human-readable textual 
  display.  This is intended to be distinct from the dumped (toString)
  representation.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>The dumped representation of THIS.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Board.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../game/AutoCommand.html" title="class in game"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../game/BoardTest.html" title="class in game"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?game/Board.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Board.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
