/*
 *  FEM.cpp
 *  NeedleSim
 *
 *  Created by Nuttapong Chentanez on 10/12/07.
 *  Copyright 2007 __MyCompanyName__. All rights reserved.
 *
 */

#ifndef _DEBUG
#ifndef NOOMP
   #include <omp.h>
#endif
#endif

#include <sstream>
#include "dsyevh3.h"
#include "Wm4Matrix3.h"
#include "FEM.h"
#include <cstdio>
#include <cstdlib>

#ifndef NO_GRAPHICS
#include "GL/glut.h"
#endif
#include <fstream>
#include "topology.h"

//#include <process.h>

#include "integrator.h"
using namespace std;
#define USE_FORCE_TET
//#define CUTTEST

//extern LOGGILE_TYPE logfile;
real sumTime = 0.0;

// Debug vector
CFEMMesh::~CFEMMesh() {
   SAFE_DELETE(topology);
	SAFE_DELETE(K);
   SAFE_DELETE(D);
   SAFE_DELETE(integrator);
}
void CFEMMesh::CopyMatProps() {
   // Material parameters
   for (int i = 0; i < numMaterials; i++) {
      real E = config.E[i]; // Young modulus, the more the stiffer, must be > 0, can go to very large eg. 10^10
      real v = config.v[i]; // Poisson ratio, how compressible the material is -1 to 0.5, mostly between 0 to 0.5
      rhos[i] = config.rho[i];	// Density
	   lambdas[i] = v*E/((1+v)*(1-2*v));   
	   mus[i] = E/(2*(1+v));
      twoMus[i] = 2.0f * mus[i];
      psis[i] = config.psi[i];
      phis[i] = config.phi[i];
      twoPhis[i] = 2.0f*phis[i];
   }
}

void CFEMMesh::CommonConstructor() {
   	// Material parameters

   D = 0;
	K = 0;
	
   //integrator = IMPLICIT_NEWMARK;
   switch (config.integrator) {
      case IMPLICIT_EULER: buildK = false; buildD = true; integrator = new CImplicitEuler(*this); break;
      case EXPLICIT_EULER: buildK = false; buildD = false; integrator = new CExplicitEuler(*this);break;
      case EXPLICIT_MIDPOINT: buildK = false; buildD = false; integrator = new CExplicitMidpoint(*this);break;
      case IMPLICIT_NEWMARK: buildK = true; buildD = true; integrator = new CImplicitNewmark(*this, config.beta, config.gamma); break;
   }

   timer.Start();
	PreComputations();
   //cout<<"Pre computation takes "<<timer.Stop()<<" second"<<endl;

   timer.Start();
 //  ComputeABExpression();

   // Handle the tip node
   // Set some constraints
   InitializeTipInfo();
   //cout<<"Compute AB expression takes "<<timer.Stop()<<" second"<<endl;
   //cout<<"Num nodes = "<<numNodes<<" Num tets = "<<numTets<<" Num tris = "<<numTris<<endl;

   topology = new CTetTopology(*this);
   /*
   bool validTop = topology->VerifyValidTopology();
   if (validTop) 
      cout<<"Topology is valid!"<<endl; else
      cout<<"Topology is invalid!!!"<<endl;
      */
   cutTip.index = 0;

}

CFEMMesh::CFEMMesh(CConfig& configi, vector<VEC3>& matPosi, vector<VEC3>& worldPosi, vector<VEC3>& velocityi, vector<VEC3>& accelerationi, vector<CTet>& tet2nodei, vector<int>& groupsi, vector<int>& fixPosNodes) : config(configi), cutTip(configi){
   numNodes = matPosi.size();
   numTets = tet2nodei.size();
   matPos = matPosi;
   worldPos = worldPosi;
   velocity = velocityi;
   acceleration = accelerationi;
   tet2node = tet2nodei;
   groups = groupsi;
   CopyMatProps();

   mass.resize(numNodes, 0.0f);  
   force.resize(numNodes);

   for (int i = 0; i < fixPosNodes.size(); i++) {
      permVconst.push_back(CVConst(fixPosNodes[i], VEC3(0.0f, 0.0f, 0.0f)));
   }

   // Now, since tri2node is not given, produce one

   memset(&force[0],0,sizeof(numNodes)*sizeof(VEC3));

   CommonConstructor();   
}

CFEMMesh::CFEMMesh(CConfig& configi, CConstraintDecision* cond) : config(configi), cutTip(configi) {

	// Read from a .mesh generated by NetGen
	worldPos.clear();
	matPos.clear();
	tet2node.clear();
   groups.clear();
   CopyMatProps();



   if (string(config.inputMesh).find(".mesh") != string::npos) {
      //cout<<"Loading a mesh file"<<endl;
      FILE* f = fopen(config.inputMesh.c_str(), "rt");
	   fscanf(f, "%d", &numNodes);
	   VEC3 pos;
	   ////logfile<<"Number of nodes = "<<numNodes<<endl;
	   force.resize(numNodes);
	   velocity.resize(numNodes, VEC3(0.0f, 0.0f, 0.0f));
      acceleration.resize(numNodes, VEC3(0.0f, 0.0f, 0.0f));
	   mass.resize(numNodes, 0.0f);  
	   for (int i = 0; i < numNodes; i++) {
         #ifdef USE_DOUBLE
		      fscanf(f, "%lf %lf %lf", &pos[0], &pos[1], &pos[2]);
         #else
            fscanf(f, "%f %f %f", &pos[0], &pos[1], &pos[2]);
         #endif
   //      pos[2] *= 0.05;
		   matPos.push_back(pos);
		   //pos[1] += 1000.0;
         #ifdef ONE_TET
            pos[0]*=-1.0;
         #endif

		   worldPos.push_back(pos);
	   }
	   fscanf(f,"%d", &numTets);
	   ////logfile<<"Number of tet2node = "<<numTets<<endl;
   	
	   int group;
	   CTet tet;
	   for (int i = 0; i < numTets; i++) {
		   fscanf(f,"%d %d %d %d %d", &group, &tet[0], &tet[1], &tet[2], &tet[3]);
		   tet[0]--; tet[1]--; tet[2]--; tet[3]--;  // Convert index to be 0-based instead of 1
		   tet2node.push_back(tet);
         groups.push_back(group);
	   }
   	
	   CTri tri;
	   fscanf(f,"%d", &numTris);
	   ////logfile<<"Number of triangles = "<<numTris<<endl;
   	
	   for (int i = 0; i < numTris; i++) {
		   fscanf(f,"%d %d %d %d", &group, &tri[0], &tri[1], &tri[2]);
		   tri[0]--; tri[1]--; tri[2]--;
		   tri2node.push_back(tri);
	   }
   	
	   fclose(f);
   } else {
      //cout<<"Loading tetgen file"<<endl;
      FILE *f;
      int junk1, junk2, junk3;
      // Load node position
      f = fopen(string(string(config.inputMesh) + ".node").c_str(), "rt");
	   fscanf(f, "%d %d %d %d", &numNodes, &junk1, &junk2, &junk3);
	   VEC3 pos;
	   //cout<<"Number of nodes = "<<numNodes<<endl;
	   force.resize(numNodes);
	   velocity.resize(numNodes, VEC3(0.0f, 0.0f, 0.0f));
      acceleration.resize(numNodes, VEC3(0.0f, 0.0f, 0.0f));
	   mass.resize(numNodes, 0.0f);  
	   for (int i = 0; i < numNodes; i++) {
         #ifdef USE_DOUBLE
		      fscanf(f, "%d %lf %lf %lf", &junk1, &pos[0], &pos[1], &pos[2]);
         #else
            fscanf(f, "%d %f %f %f", &junk1, &pos[0], &pos[1], &pos[2]);
         #endif

		   matPos.push_back(pos);
         worldPos.push_back(matPos[i]);
	   }
      fclose(f);


      // Load element
      f = fopen(string(string(config.inputMesh) + ".ele").c_str(), "rt");
	   fscanf(f,"%d %d %d", &numTets, &junk1, &junk2);
	   cout<<"Number of tet2node = "<<numTets<<endl;
   	
	   int group;
	   CTet tet;
	   for (int i = 0; i < numTets; i++) {
		   fscanf(f,"%d %d %d %d %d %d", &junk1, &tet[0], &tet[1], &tet[3], &tet[2], &group);
		  // tet[0]--; tet[1]--; tet[2]--; tet[3]--;  // Convert index to be 0-based instead of 1
		   tet2node.push_back(tet);
         groups.push_back(group);

	   }
      fclose(f);
      // Load face
      f = fopen(string(string(config.inputMesh) + ".face").c_str(), "rt");
	   CTri tri;
	   fscanf(f,"%d %d", &numTris, &junk1);
	   //cout<<"Number of triangles = "<<numTris<<endl;
   	
	   for (int i = 0; i < numTris; i++) {
		   fscanf(f,"%d %d %d %d %d", &junk1, &tri[0], &tri[1], &tri[2], &group);
//		   tri[0]--; tri[1]--; tri[2]--;
		   tri2node.push_back(tri);
	   }
   	
	   fclose(f);
   }
   VEC3 mins(1e10, 1e10, 1e10), maxs(-mins);

   for (int i = 0; i < numNodes; i++) {
      VEC3& pos = matPos[i];
      if (pos[0] < mins[0]) mins[0] = pos[0];
      if (pos[0] > maxs[0]) maxs[0] = pos[0];
      if (pos[1] < mins[1]) mins[1] = pos[1];
      if (pos[1] > maxs[1]) maxs[1] = pos[1];
      if (pos[2] < mins[2]) mins[2] = pos[2];
      if (pos[2] > maxs[2]) maxs[2] = pos[2];

   }
   //cout<<"Mins = "<<mins[0]<<" "<<mins[1]<<" "<<mins[2]<<endl;
   //cout<<"Maxs = "<<maxs[0]<<" "<<maxs[1]<<" "<<maxs[2]<<endl;

   VEC3 mid = 0.5*(mins+maxs);
   real dim = max(max(maxs[0]-mins[0],maxs[1]-mins[1]),maxs[2]-mins[2]);
   real scale = config.sceneScale / dim;
   MATRIX3 rot;
   rot.MakeIdentity();
   //.rot.FromAxisAngle(VEC3(0,0,1), PI/3);

   // As Ron requested, let's ignore scene scaling for now.
   if (config.noRescaleNoTranslate) {
      mid = VEC3(0,0,0);
      scale = 1;
   }

   for (int i = 0; i < numNodes; i++) {
      matPos[i] = (matPos[i]-mid)*scale;

      VEC3 vv(matPos[i][0], matPos[i][1], matPos[i][2]), vvv;
      vvv = rot*vv;
      worldPos[i] = (*(VEC3 *)(&vvv[0] ));

      //worldPos[i] = matPos[i];

   }
   for (int i = 0; i < numNodes; i++) {
   #ifdef ONE_TET
      if (matPos[i][1] < -1110.001) {
   #else
//      if (matPos[i][1] < 0.001) {
        //if ((matPos[i][1] < 0.05) || (matPos[i][1] > 0.95)) {
      //if (matPos[i][1] > 0.475*config.sceneScale) {
      //if ((matPos[i][1] > 0.475*config.sceneScale) || (matPos[i][1] < -0.475*config.sceneScale)) {
      if ((*cond)(config, i, matPos[i])) {

   #endif
         permVconst.push_back(CVConst(i, VEC3(0.0f, 0.0f, 0.0f)));
      }
   }

   // Compute topology
   //CTetTopology::ComputeTopology(tet2node, matPos, tet2tet);
	
   CommonConstructor();   
   memset(&force[0],0,force.size()*sizeof(VEC3));
}

bool saveViewingParameters = true;
double modelViewMat[16], projectionMat[16];
int viewport[4];

int CFEMMesh::Pick(int x, int y, int rad) { // Return the vertex that is projected to within rad pixels from (x,y)
   #ifndef NO_GRAPHICS

   int minI = -1;
   real minZ = 1e10;
   for (int i = 0; i < numNodes; i++) {
      double px,py,pz;
      gluProject(worldPos[i][0], worldPos[i][1], worldPos[i][2],
                 modelViewMat, projectionMat, viewport, &px, &py, &pz);
//      cout<<px<<" "<<py<<" "<<pz<<endl;
      if (pz > 0) {
         if ((abs(px-x) < rad) && (abs(py-y) < rad)) {
            if (pz < minZ) {
               minI = i;
               minZ = pz;
            }
         }
      }
   }
   return minI;
   #else
      Error("Should never be called because graphics is not supported");
      return 0;
   #endif
}

extern void WriteMFile(CCoorMatrix<real>& mat, string name);


inline void CFEMMesh::SVD3x3(MATRIX3& mat, MATRIX3& U, MATRIX3& D, MATRIX3& Vt) {
   MATRIX3 FtF = mat.Transpose() * mat;

   MATRIX3 V;
   //FtF.EigenDecomposition(V, D);
   
   double A[3][3] = {{FtF[0][0], FtF[0][1], FtF[0][2]},
                     {FtF[1][0], FtF[1][1], FtF[1][2]},
                     {FtF[2][0], FtF[2][1], FtF[2][2]}};

   double Q[3][3];
   double w[3];
   if (dsyevh3(A, Q, w) == -1) cout<<"eigen solve failed"<<endl;
   for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
         V[i][j] = Q[i][j];
      }
   }         
   D[0][0] = (w[0] > 0.0 ? w[0] : 0.0);
   D[1][1] = (w[1] > 0.0 ? w[1] : 0.0);
   D[2][2] = (w[2] > 0.0 ? w[2] : 0.0);
   


   if (V.Determinant() < 0) {
      V[0][0] *= -1;
      V[1][0] *= -1;
      V[2][0] *= -1;
      //cout<<"Neg det v"<<endl;
   }
   D[0][0] = sqrt(D[0][0]);
   D[1][1] = sqrt(D[1][1]);
   D[2][2] = sqrt(D[2][2]);

   U = mat*V;
   real thresh = config.svdThreshold;
   int numNear0 = 0;
   for (int i = 0; i < 3; i++) {
      if (abs(D[i][i]) < thresh) {
         // Near 0
         numNear0++;
      } else {
         real id = 1.0 / D[i][i];
         U[0][i] *= id;
         U[1][i] *= id;
         U[2][i] *= id;
      }
   }
   const int others[3][2] = {{1,2},{2,0}, {0,1}};
   if (numNear0 != 0) {
      //cout<<"Num near 0 = "<<numNear0<<endl;
      //continue;
   }
   if (numNear0 == 1) {
      
      for (int i = 0; i < 3; i++) {
         if (abs(D[i][i]) < thresh) {
            int ot1 = others[i][0];
            int ot2 = others[i][1];
            VEC3 v = VEC3(U[0][ot1], U[1][ot1], U[2][ot1]).Cross(VEC3(U[0][ot2], U[1][ot2], U[2][ot2]));
            //v.Normalise();
            U[0][i] = v[0];
            U[1][i] = v[1];
            U[2][i] = v[2];
            /*if (D[i][i] < 0) D[i][i] = 0; else
                             D[i][i] = 1;*/
            //D[i][i] = 0;
            break;
         }
      }
   } else
   if (numNear0 == 2) {
      for (int i = 0; i < 3; i++) {
         if (abs(D[i][i]) > thresh) {
            VEC3 u,v,w = VEC3(U[0][i], U[1][i], U[2][i]);
            GenerateOrthonormalBasis(u,v,w);
            int ot1 = others[i][0];
            int ot2 = others[i][1];
            U[0][ot1] = u[0];
            U[1][ot1] = u[1];
            U[2][ot1] = u[2];

            U[0][ot2] = v[0];
            U[1][ot2] = v[1];
            U[2][ot2] = v[2];

            //D[ot1][ot1] = 0;
            //D[ot2][ot2] = 0;
            break;
         }
      }

   } else
   if (numNear0 == 3) {
      // Make it identity
      U.MakeIdentity();
   } 

   if (U.Determinant() < 0) {
      //cout<<"Neg det u"<<endl;
      // Has to negate D 
      real minA = 1e50;
      int indA;
      for (int i = 0; i < 3; i++) {
         real aa = D[i][i];
         if (aa < minA) {
            minA = aa;
            indA = i;                  
         }
      }
      D[indA][indA] *= -1;
      U[0][indA] *= -1;
      U[1][indA] *= -1;
      U[2][indA] *= -1;

   }
   //U.Orthonormalize();
   //V.Orthonormalize();
   Vt = V.Transpose();
}		

#define beta_0_4 coef[0]
#define beta_1_4_p_0_5 coef[1]
#define beta_2_4_p_0_6 coef[2]
#define beta_1_5 coef[3]
#define beta_2_5_p_1_6 coef[4]
#define beta_2_6 coef[5]
#define beta_4_4 coef[6]
#define two_beta_4_5 coef[7]
#define two_beta_4_6 coef[8]
#define beta_5_5 coef[9]
#define two_beta_5_6 coef[10]
#define beta_6_6 coef[11]
#define beta_4_9 coef[12]
#define beta_4_10 coef[13]
#define beta_5_9 coef[14]
#define beta_5_10_p_6_9 coef[15]
#define beta_6_10 coef[16]
#define beta_4_14 coef[17]
#define beta_5_14 coef[18]
#define beta_6_14 coef[19]
#define beta_9_0 coef[20]
#define beta_9_1 coef[21]
#define beta_9_2_p_10_1 coef[22]
#define beta_10_0 coef[23]
#define beta_10_2 coef[24]
#define beta_9_4 coef[25]
#define beta_9_5 coef[26]
#define beta_9_6_p_10_5 coef[27]
#define beta_10_4 coef[28]
#define beta_10_6 coef[29]
#define beta_9_9 coef[30]
#define two_beta_9_10 coef[31]
#define beta_10_10 coef[32]
#define beta_9_14 coef[33]
#define beta_10_14 coef[34]
#define beta_14_0 coef[35]
#define beta_14_1 coef[36]
#define beta_14_2 coef[37]
#define beta_14_4 coef[38]
#define beta_14_5 coef[39]
#define beta_14_6 coef[40]
#define beta_14_9 coef[41]
#define beta_14_10 coef[42]
#define beta_14_14 coef[43]
real maxEntry = -1e6;

/*
void GenRotMat(const VEC3& v0, const VEC3& v1, const VEC3& v2, MATRIX3& mat) {
   VEC3 b0 = v0 + v1;
   b0.Normalize();
   
   VEC3 b1 = v2.Cross(b0);
   b1.Normalize();
   VEC3 b2 = b0.Cross(b1);

   mat(0,0) = b0[0];
   mat(1,0) = b0[1];
   mat(2,0) = b0[2];

   mat(0,1) = b1[0];
   mat(1,1) = b1[1];
   mat(2,1) = b1[2];

   mat(0,2) = b2[0];
   mat(1,2) = b2[1];
   mat(2,2) = b2[2];
}*/

inline real signD(real a) {
   if (a > 0) return 1; else return -1;
}

void CFEMMesh::ComputeTetProperties(int i) {
   // If the array is too small, expand it 
   if (i >= baryMat.size()) {
 	   baryMat.resize(i+1);
      tetVol.resize(i+1);
      pcCoef.resize(i+1);
      Bm.resize(i+1);
      tetVNormals.resize(i+1);
      jblocks.resize(i+1); // Not being updated for now
      rotation.resize(i+1);
      forceTets.resize(i+1);
      tetRCond.resize(i+1);
   }

   int group = groups[i];
   real rho = rhos[group];
   VEC3 zero(0.0,0.0,0.0);
   
   PCCoef& coef = pcCoef[i];
   int* tet = &tet2node[i][0];
   VEC3 m0(matPos[tet[0]]),
       m1(matPos[tet[1]]),
       m2(matPos[tet[2]]),
       m3(matPos[tet[3]]);

   VEC3 p1(m1-m0),
       p2(m2-m0),
       p3(m3-m0);
   
   MATRIX3 mat(p1[0],p2[0],p3[0],
                          p1[1],p2[1],p3[1],
                          p1[2],p2[2],p3[2]);
   real* mmm = mat[0];

   const real limit = config.baryThreshold; 
   static real maxrcond = 0;
   {
      MATRIX3 U, D, Vt;
      SVD3x3(mat, U, D, Vt);


      real maxs = max(max(abs(D[0][0]), abs(D[1][1])), abs(D[2][2]));
      real mins = min(min(abs(D[0][0]), abs(D[1][1])), abs(D[2][2]));
      real rcond = maxs / mins;
      tetRCond[i] = rcond;
      /*
      if (rcond > maxrcond) {
         maxrcond = rcond;
         cout<<"Rcond = "<<maxrcond<<endl;
      }
      if (rcond > limit) {
         real large = maxs / limit;
         D[0][0] = signD(D[0][0])*max(abs(D[0][0]), large);
         D[1][1] = signD(D[1][1])*max(abs(D[1][1]), large);
         D[2][2] = signD(D[2][2])*max(abs(D[2][2]), large);

      }
      mat.SingularValueComposition(U,D,Vt);
      p1 = VEC3(mmm[0], mmm[3], mmm[6]);
      p2 = VEC3(mmm[1], mmm[4], mmm[7]);
      p3 = VEC3(mmm[2], mmm[5], mmm[8]);
      */
   }
   

   CMat3x3 qt;
   QR3(mmm, &qt[0]);

   //rotMat[i] = qt;

   VEC3 rp1,rp2,rp3;

   Mul3(qt, p1, rp1);
   Mul3(qt, p2, rp2);
   Mul3(qt, p3, rp3);
   

   GenRotMat(rp1, rp2, rp3, rotation[i]);
 


   tet = &tet2node[i][0];
   if (config.forceMethod == FORCE_NODE_ROT_LINEAR) {
      buildBaryMat(&matPos[tet[0]][0], &matPos[tet[1]][0], &matPos[tet[2]][0], &matPos[tet[3]][0], (real*)(&baryMat[i]));
   } else {
	   
	   buildBaryMat(&zero[0], &rp1[0], &rp2[0], &rp3[0], (real*)(&baryMat[i]));
   }


/*
   cout<<rp1[0]<<" "<<rp1[1]<<" "<<rp1[2]<<endl;
   cout<<rp2[0]<<" "<<rp2[1]<<" "<<rp2[2]<<endl;
   cout<<rp3[0]<<" "<<rp3[1]<<" "<<rp3[2]<<endl;
*/
   // Compute Bm
   // Convention is that the normal(computed in conventional order) of the opposite tri of vertex i point toward the vertex i
   /*const int ind[4][3] = {
            {1,3,2}, 
            {0,2,3},
            {0,3,1},
            {0,1,2}};*/

   VEC3 faceAN[4];
   VEC3 sumAN(0,0,0);

   faceAN[0] = (rp3 - rp1).Cross(rp2 - rp1);
   faceAN[1] = rp2.Cross(rp3);
   faceAN[2] = rp3.Cross(rp1);
   faceAN[3] = rp1.Cross(rp2);

   sumAN = faceAN[0] + faceAN[1] + faceAN[2] + faceAN[3];
   

   for (int k = 1; k < 4; k++) {
      VEC3 col = (faceAN[k] - sumAN) / 6;
      Bm[i][0][k-1] = col[0];
      Bm[i][1][k-1] = col[1];
      Bm[i][2][k-1] = col[2];                 
   }

   for (int k = 0; k < 4; k++) {
      tetVNormals[i].N[k] = (faceAN[k] - sumAN) / 6;

   }

   

	real vol = TetVol(&matPos[tet[0]][0], &matPos[tet[1]][0], &matPos[tet[2]][0], &matPos[tet[3]][0]);
   tetVol[i] = vol;
	mass[tet[0]] += 0.25*rho*vol;
	mass[tet[1]] += 0.25*rho*vol;
	mass[tet[2]] += 0.25*rho*vol;
	mass[tet[3]] += 0.25*rho*vol;
   
   /*
   for (int k = 0; k < 4; k++) {
      for (int j = 0; j < 4; j++) {
         if (abs(baryMat[i][k*4 + j]) > 100) {
            if (baryMat[i][k*4 + j] < 0) {
               baryMat[i][k*4 + j] = -100;
            } else {
               baryMat[i][k*4 + j] = 100;
            }
         }

         if (abs(baryMat[i][k*4 + j]) > maxEntry) {
            maxEntry = abs(baryMat[i][k*4 + j]);
         }

      }
   }*/

/*      fprintf(ssss,"Tet %d\n",i);
   for (int k = 0; k < 4; k++) {
   for (int j = 0; j < 4; j++) {
      if (abs(baryMat[i][k*4 + j]) < 1e-8) baryMat[i][k*4 + j] = 0.0;
      fprintf(ssss, "%lg ",baryMat[i][k*4 + j]);
   }
   fprintf(ssss, "\n");
   }
   fprintf(ssss, "\n");
*/
   CMat4x4& beta=baryMat[i];

   beta_0_4=beta[0]*beta[4],
   beta_1_4_p_0_5=beta[1]*beta[4]+beta[0]*beta[5],
   beta_2_4_p_0_6 = beta[2]*beta[4]+beta[0]*beta[6],
   beta_1_5=beta[1]*beta[5],
   beta_2_5_p_1_6=beta[2]*beta[5]+beta[1]*beta[6],
   beta_2_6=beta[2]*beta[6],
   beta_4_4=beta[4]*beta[4],
   two_beta_4_5 = 2.0*beta[4]*beta[5],
   two_beta_4_6 = 2.0*beta[4]*beta[6],
   beta_5_5 = beta[5]*beta[5],
   two_beta_5_6 = 2.0*beta[5]*beta[6],
   beta_6_6=beta[6]*beta[6],
   beta_4_9=beta[4]*beta[9],
   beta_4_10=beta[4]*beta[10],
   beta_5_9=beta[5]*beta[9],
   beta_5_10_p_6_9=beta[5]*beta[10]+beta[6]*beta[9],
   beta_6_10=beta[6]*beta[10],
   beta_4_14=beta[4]*beta[14],
   beta_5_14=beta[5]*beta[14],
   beta_6_14=beta[6]*beta[14],
   beta_9_0=beta[9]*beta[0],
   beta_9_1=beta[9]*beta[1],
   beta_9_2_p_10_1=beta[9]*beta[2]+beta[10]*beta[1],
   beta_10_0=beta[10]*beta[0],
   beta_10_2=beta[10]*beta[2],
   beta_9_4=beta[9]*beta[4],
   beta_9_5=beta[9]*beta[5],
   beta_9_6_p_10_5=beta[9]*beta[6]+beta[10]*beta[5],
   beta_10_4=beta[10]*beta[4],
   beta_10_6=beta[10]*beta[6],
   beta_9_9=beta[9]*beta[9],
   two_beta_9_10=2.0*beta[9]*beta[10],
   beta_10_10=beta[10]*beta[10],
   beta_9_14=beta[9]*beta[14],
   beta_10_14=beta[10]*beta[14],
   beta_14_0=beta[14]*beta[0],
   beta_14_1=beta[14]*beta[1],
   beta_14_2=beta[14]*beta[2],
   beta_14_4=beta[14]*beta[4],
   beta_14_5=beta[14]*beta[5],
   beta_14_6=beta[14]*beta[6],
   beta_14_9=beta[14]*beta[9],
   beta_14_10=beta[14]*beta[10],
   beta_14_14=beta[14]*beta[14];

   // Build the unrotated bary mat as well 
   //buildBaryMat(&matPos[tet[0]][0], &matPos[tet[1]][0], &matPos[tet[2]][0], &matPos[tet[3]][0], (real*)(&baryMat[i]));
 

   // Compute jacobian block
   ComputeJBlock(i);
}

void CFEMMesh::PreComputations() {
	// Build bary-centric matrix
   //vector<CForceTet> ft
   PreComputeElementRotLinear();

	for (int i = 0; i < numTets; i++)  {
      ComputeTetProperties(i);
	}

   FindEdges();
   //cout<<"Max entry = "<<maxEntry<<endl;
	


//   if (((config.forceMethod == FORCE_CAUCHY) ||
       //(config.forceMethod == FORCE_IRVING) ||
       //(config.forceMethod == FORCE_MIXED_CI)) && (config.integrator == IMPLICIT_EULER)) {
   //}
}

#define delta(a, b) (((a) == (b)) ? 1.0f : 0.0f) 

void OutMat(const MATRIX3& mat) {
   cout<<mat[0][0]<<" "<<mat[0][1]<<" "<<mat[0][2]<<" "<<endl<<
         mat[1][0]<<" "<<mat[1][1]<<" "<<mat[1][2]<<" "<<endl<<
         mat[2][0]<<" "<<mat[2][1]<<" "<<mat[2][2]<<endl;
}

void CFEMMesh::ComputeForceCauchy(MATRIX3& D, MATRIX3& theRot, int t, VEC3& f1, VEC3& f2, VEC3& f3, MATRIX3* vD) {
   int group = groups[t];
   real lambda = lambdas[group];
   real twoMu = twoMus[group];
   real twoPhi = twoPhis[group];
   real psi = psis[group];

   real lambdatracem3 = (D[0][0] + D[1][1] + D[2][2] - 3) * lambda;
   D[0][0] = twoMu*(D[0][0]-1) + lambdatracem3;
   D[0][1] *= twoMu;
   D[0][2] *= twoMu;
   D[1][0] *= twoMu;
   D[1][1] = twoMu*(D[1][1]-1) + lambdatracem3;
   D[1][2] *= twoMu;
   D[2][0] *= twoMu;
   D[2][1] *= twoMu;
   D[2][2] = twoMu*(D[2][2]-1) + lambdatracem3;

   if (config.dampPhysical) {
      MATRIX3& vstress = *vD;
      /*
      real psitracem3 = (vstress[0][0] + vstress[1][1] + vstress[2][2] - 3) * psi;
      vstress[0][0] = twoPhi*(vstress[0][0]-1) + psitracem3;
      vstress[0][1] *= twoPhi;
      vstress[0][2] *= twoPhi;
      vstress[1][0] *= twoPhi;
      vstress[1][1] = twoPhi*(vstress[1][1]-1) + psitracem3;
      vstress[1][2] *= twoPhi;
      vstress[2][0] *= twoPhi;
      vstress[2][1] *= twoPhi;
      vstress[2][2] = twoPhi*(vstress[2][2]-1) + psitracem3;*/
      real psitracem3 = (vstress[0][0] + vstress[1][1] + vstress[2][2]) * psi;
      vstress[0][0] = twoPhi*(vstress[0][0]) + psitracem3;
      vstress[0][1] = vstress[1][0] = 0.5*twoPhi*(vstress[0][1] + vstress[1][0]);
      vstress[0][2] = vstress[2][0] = 0.5*twoPhi*(vstress[0][2] + vstress[2][0]);
      vstress[1][1] = twoPhi*(vstress[1][1]) + psitracem3;
      vstress[1][2] = vstress[2][1] = 0.5*twoPhi*(vstress[1][2] + vstress[2][1]);
      vstress[2][2] = twoPhi*(vstress[2][2]) + psitracem3;

      D += vstress;
   }
   // Need to limit the stress magnitude as well to avoid blowing up the system
   for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
         if (abs(D[i][j]) > config.irvingStressLimit) {               
            if (D[i][j] > 0) {
               D[i][j] = config.irvingStressLimit;
            } else {
               D[i][j] = -config.irvingStressLimit;
            }
         }
      }
   }
   //MATRIX3 P = theRot.TransposeTimes(D);
   MATRIX3 fff = theRot.TransposeTimes((D.TransposeTimes(Bm[t])));


   f1 = VEC3(fff[0][0], fff[1][0], fff[2][0]); 
   f2 = VEC3(fff[0][1], fff[1][1], fff[2][1]); 
   f3 = VEC3(fff[0][2], fff[1][2], fff[2][2]); 

   VEC3 f4 = theRot.TransposeTimes(D.TransposeTimes(tetVNormals[t].N[0]));
   /*
   if (t % 1000 == 0) {
      float ddd = ((f4+f1+f2+f3).Length());
      cout<<ddd<<" "<<endl;
   }*/

   MATRIX3 eye;
   eye.MakeIdentity();
   
   if (buildD || buildK) {
      AddJacobianContribution(t, eye, theRot.Transpose(), lambda, twoMu, psi, twoPhi);
   }


}

void CFEMMesh::ComputeForceIrving(MATRIX3& mat, MATRIX3& theRot, int t, VEC3& f1, VEC3& f2, VEC3& f3, MATRIX3* vMat) {
   //MATRIX3 xmat;
   MATRIX3 U, D, Vt;
   int group = groups[t];
   real lambda = lambdas[group];
   real twoMu = twoMus[group];
   real twoPhi = twoPhis[group];
   real psi = psis[group];

   
   if (tetRCond[t] > config.rcondLimit) {
      real factor = exp(-((tetRCond[t]-config.rcondLimit)*config.youngDecayFactor));
      lambda *= factor;
      twoMu *= factor;
      twoPhi *= factor;
      psi *= factor;
   //   cout<<"need to limit!"<<endl;
   }

   SVD3x3(mat, U, D, Vt);
   real lambdatracem3 = (D[0][0] + D[1][1] + D[2][2] - 3) * lambda;
   D[0][0] = twoMu*(D[0][0]-1) + lambdatracem3;
   D[1][1] = twoMu*(D[1][1]-1) + lambdatracem3;
   D[2][2] = twoMu*(D[2][2]-1) + lambdatracem3;

   if (config.dampPhysical) {
      /*
      MATRIX3 vstress = (U.TransposeTimes(*vMat)).TimesTranspose(Vt);
      real psitracem3 = (vstress[0][0] + vstress[1][1] + vstress[2][2] - 3) * psi;
      vstress[0][0] = twoPhi*(vstress[0][0]-1) + psitracem3;
      vstress[0][1] *= twoPhi;
      vstress[0][2] *= twoPhi;
      vstress[1][0] *= twoPhi;
      vstress[1][1] = twoPhi*(vstress[1][1]-1) + psitracem3;
      vstress[1][2] *= twoPhi;
      vstress[2][0] *= twoPhi;
      vstress[2][1] *= twoPhi;
      vstress[2][2] = twoPhi*(vstress[2][2]-1) + psitracem3;*/

      /*
      MATRIX3 vstress = (U.TransposeTimes(*vMat)).TimesTranspose(Vt);
      real psitracem3 = (vstress[0][0] + vstress[1][1] + vstress[2][2]) * psi;
      vstress[0][0] = twoPhi*(vstress[0][0]) + psitracem3;
      vstress[0][1] *= twoPhi;
      vstress[0][2] *= twoPhi;
      vstress[1][0] *= twoPhi;
      vstress[1][1] = twoPhi*(vstress[1][1]) + psitracem3;
      vstress[1][2] *= twoPhi;
      vstress[2][0] *= twoPhi;
      vstress[2][1] *= twoPhi;
      vstress[2][2] = twoPhi*(vstress[2][2]) + psitracem3;
      */
      MATRIX3 vstress = (U.TransposeTimes(*vMat)).TimesTranspose(Vt);
      real psitracem3 = (vstress[0][0] + vstress[1][1] + vstress[2][2]) * psi;
      vstress[0][0] = twoPhi*(vstress[0][0]) + psitracem3;
      vstress[0][1] = vstress[1][0] = 0.5*twoPhi*(vstress[0][1] + vstress[1][0]);
      vstress[0][2] = vstress[2][0] = 0.5*twoPhi*(vstress[0][2] + vstress[2][0]);
      vstress[1][1] = twoPhi*(vstress[1][1]) + psitracem3;
      vstress[1][2] = vstress[2][1] = 0.5*twoPhi*(vstress[1][2] + vstress[2][1]);
      vstress[2][2] = twoPhi*(vstress[2][2]) + psitracem3;

      D += vstress;
      // Need to limit the stress magnitude as well to avoid blowing up the system
      for (int i = 0; i < 3; i++) {
         for (int j = 0; j < 3; j++) {
            if (abs(D[i][j]) > config.irvingStressLimit) {               
               if (D[i][j] > 0) {
                  D[i][j] = config.irvingStressLimit;
               } else {
                  D[i][j] = -config.irvingStressLimit;
               }
            }
         }
      }
   } else {
      // Need to limit the stress magnitude as well to avoid blowing up the system  
      for (int i = 0; i < 3; i++) {
         if (abs(D[i][i]) > config.irvingStressLimit) {               
            if (D[i][i] > 0) {
               D[i][i] = config.irvingStressLimit;
            } else {
               D[i][i] = -config.irvingStressLimit;
            }
         }
      }
   }


   //xmat.SingularValueComposition(U,D,Vt);

   /*
   mat.SingularValueDecomposition(U,D,Vt);


   xmat.SingularValueComposition(U,D,Vt);

   real detU = U.Determinant();
   if (detU < 0) {
   Error("Crap detU < 0");
   exit(0);
   }
   real detV = Vt.Determinant();
   if (detV < 0) {
   cout<<"detV < 0"<<endl;            
   real minA = 1e50;
   int indA;
   for (int i = 0; i < 3; i++) {
   real aa = D[i][i];
   if (aa < minA) {
   minA = aa;
   indA = i;                  
   }
   }
   D[indA][indA] *= -1;
   Vt[indA][0] *= -1;
   Vt[indA][1] *= -1;
   Vt[indA][2] *= -1;
   DDD = true;
   //Error("Crap detV < 0");
   //exit(0);
   }
   if (DDD) cout<<"For tet "<<t<<endl;
   if (DDD) cout<<"mat"<<endl;
   if (DDD) OutMat(mat);
   if (DDD) cout<<endl;

   int numDL0 = (D[0][0] < 0) + (D[1][1] < 0) + (D[2][2] < 0);
   cout<<numDL0<<endl;
   if (numDL0 == 2) {
   cout<<"Need to flip"<<endl;
   // Need to flip
   for (int i = 0; i < 3; i++) {
   if (D[i][i] < 0) {
   D[i][i]*=-1;
   U[0][i]*=-1;
   U[1][i]*=-1;
   U[2][i]*=-1;
   }
   }
   }
   */
   /*
   if (DDD) cout<<"For tet "<<t<<endl;
   if (DDD) cout<<"mat"<<endl;
   if (DDD) OutMat(mat);
   if (DDD) cout<<endl;

   if (DDD) cout<<"xmat"<<endl;
   if (DDD) OutMat(xmat);
   if (DDD) cout<<endl;

   if (DDD) cout<<"U"<<endl;
   if (DDD) OutMat(U);
   if (DDD) cout<<endl;

   if (DDD) cout<<"D"<<endl;
   if (DDD) OutMat(D);
   if (DDD) cout<<endl;

   if (DDD) cout<<"Vt"<<endl;
   if (DDD) OutMat(Vt);
   if (DDD) cout<<endl;
   */

/*
   for (int i = 0; i < 3; i++) {
      if (abs(D[i][i]) > maxSMag) maxSMag = abs(D[i][i]);
   }*/

   MATRIX3 P;
   P.SingularValueComposition(U, D, Vt);
   MATRIX3 fff = P.TransposeTimes(Bm[t]);

   if (config.forceMethod == FORCE_MIXED_CI) {
      fff = theRot.TransposeTimes(fff);
   }

   f1 = VEC3(fff[0][0], fff[1][0], fff[2][0]); 
   f2 = VEC3(fff[0][1], fff[1][1], fff[2][1]); 
   f3 = VEC3(fff[0][2], fff[1][2], fff[2][2]); 

   // Add jacobian
   //AddJacobianContribution(t, U, Vt.Transpose(), lambda, twoMu);
   if (buildD || buildK) {
      AddJacobianContribution(t, U, Vt.Transpose(), lambda, twoMu, psi, twoPhi);
   }
}



void CFEMMesh::ComputeForce(real dt) {
   const int nn3 = numNodes * 3;
   timer.Start();
	// Clear force
	for (int i = 0; i < numNodes; i++) {
		force[i] = VEC3(0.0f,0.0f,0.0f);
	}


   static int ccc = 0;
   ccc++;
   //cout<<ccc<<endl;
   #ifndef ONE_TET
      //if (ccc == 1000) {
        // vconst.pop_back();
         //vconst.back() = CVConst(tip.index, VEC3(0.0f, 0.0f, 0.0f));
         //vconst[vconst.size() - 1] = 
      //}
   #endif

   // Clear K and D
   if (buildK) {      
      K->ClearElements();
      //memset(K->A.begin(), 0, sizeof(real)*K->nnz());
   }
   if (buildD) {
      D->ClearElements();
      //memset(D->A.begin(), 0, sizeof(real)*D->nnz());
   }

   if (config.forceMethod != FORCE_NODE_ROT_LINEAR) {
	   //return;
	   real strain[3][3];
	   real stress[3][3];
	   real dxodu[3][3]; // dxodu[i][a] = component a of dx/du_i 

      
      // Coefficients for M and K in the A and B matrix
      //real MCoefForA = 1.0 / dt + alpha2;
      //real KCoefForA = alpha1 + 0.5*dt;

      //real MCoefForB = 1.0 / dt;
      //real KCoefForB = -0.5 * dt;    

      
      //real minDet = 1e10;
      //real maxForceMag = -1;

      //real maxSMag = -1;
      MATRIX3 theRot;
      VEC3 tmp0, tmp1, tmp2, tmp3;
      VEC3 vtmp0, vtmp1, vtmp2, vtmp3;
      //int countCauchy = 0;

      //if ((config.forceMethod == FORCE_IRVING) && (config.integrator == IMPLICIT_EULER)) {
         // Has to clear jacobian
         
      //}
          
      int t;
      #pragma omp parallel private(t, theRot, tmp0, tmp1, tmp2, tmp3, vtmp0, vtmp1, vtmp2, vtmp3, strain, stress, dxodu) 
      {
         #pragma omp for schedule (dynamic, 100) nowait
         for (t = 0; t < numTets; t++) {

            int group = groups[t];
            real lambda = lambdas[group];
            real twoMu = twoMus[group];
            real mu = mus[group];
            real twoPhi = twoPhis[group];
            real psi = psis[group];
            real rho = rhos[group];

            PCCoef& coef = pcCoef[t];
            real strain00_m2,
                 strain01_m2,
                 strain02_m2,
                 strain11_m2,
                 strain12_m2,
                 strain22_m2;
            real vstrain00,
               vstrain01,
               vstrain02,
               vstrain11,
               vstrain12,
               vstrain22;

            real stress00,
                 stress01,
                 stress02,
                 stress11,
                 stress12,
                 stress22;
            real dxodu00,
                 dxodu01,
                 dxodu02,
                 dxodu10,
                 dxodu11,
                 dxodu12,
                 dxodu20,
                 dxodu21,
                 dxodu22;

            real dvodu00,
               dvodu01,
               dvodu02,
               dvodu10,
               dvodu11,
               dvodu12,
               dvodu20,
               dvodu21,
               dvodu22;

            CMat4x4 &beta = baryMat[t];
  		      CTet& tet = tet2node[t];
		      real vol = tetVol[t];
		      real mhvol = -0.5*vol;
		      real rhovold20 = rho*vol/20.0f;
            
            VEC3 &wb0 = worldPos[tet[0]],
               &wb1 = worldPos[tet[1]],
               &wb2 = worldPos[tet[2]],
               &wb3 = worldPos[tet[3]];
            VEC3 &vb0 = velocity[tet[0]],
               &vb1 = velocity[tet[1]],
               &vb2 = velocity[tet[2]],
               &vb3 = velocity[tet[3]];
            real *w0, 
                 *w1,
                 *w2,
                 *w3;
            real *v0,
                 *v1,
                 *v2,
                 *v3;
            if ((config.forceMethod != FORCE_CAUCHY) && (config.forceMethod != FORCE_MIXED_CI)) {
            } else {
               MATRIX3 mmm;

               GenRotMat(wb1-wb0, wb2-wb0, wb3-wb0, mmm);
               theRot = rotation[t].TimesTranspose(mmm);
            }
            w0 = &wb0[0];
            w1 = &wb1[0];
            w2 = &wb2[0];
            w3 = &wb3[0];

            // Find dx/du_i
            dxodu00 = (w0[0]*beta[0] + w1[0]*beta[4] );
            dxodu01 = (w0[1]*beta[0] + w1[1]*beta[4] );
            dxodu02 = (w0[2]*beta[0] + w1[2]*beta[4] );
            dxodu10 = (w0[0]*beta[1] + w1[0]*beta[5] + w2[0]*beta[9] );
            dxodu11 = (w0[1]*beta[1] + w1[1]*beta[5] + w2[1]*beta[9] );
            dxodu12 = (w0[2]*beta[1] + w1[2]*beta[5] + w2[2]*beta[9] );
            dxodu20 = (w0[0]*beta[2] + w1[0]*beta[6] + w2[0]*beta[10] + w3[0]*beta[14]);
            dxodu21 = (w0[1]*beta[2] + w1[1]*beta[6] + w2[1]*beta[10] + w3[1]*beta[14]);
            dxodu22 = (w0[2]*beta[2] + w1[2]*beta[6] + w2[2]*beta[10] + w3[2]*beta[14]);

            if (config.dampPhysical) {
               v0 = &vb0[0];
               v1 = &vb1[0];
               v2 = &vb2[0];
               v3 = &vb3[0];
            }

            // Find dv/du_i
            if (config.dampPhysical) {
               dvodu00 = (v0[0]*beta[0] + v1[0]*beta[4] );
               dvodu01 = (v0[1]*beta[0] + v1[1]*beta[4] );
               dvodu02 = (v0[2]*beta[0] + v1[2]*beta[4] );
               dvodu10 = (v0[0]*beta[1] + v1[0]*beta[5] + v2[0]*beta[9] );
               dvodu11 = (v0[1]*beta[1] + v1[1]*beta[5] + v2[1]*beta[9] );
               dvodu12 = (v0[2]*beta[1] + v1[2]*beta[5] + v2[2]*beta[9] );
               dvodu20 = (v0[0]*beta[2] + v1[0]*beta[6] + v2[0]*beta[10] + v3[0]*beta[14]);
               dvodu21 = (v0[1]*beta[2] + v1[1]*beta[6] + v2[1]*beta[10] + v3[1]*beta[14]);
               dvodu22 = (v0[2]*beta[2] + v1[2]*beta[6] + v2[2]*beta[10] + v3[2]*beta[14]);
            }

            real det = dxodu00*(dxodu11*dxodu22 - dxodu21*dxodu12) - dxodu01*(dxodu10*dxodu22-dxodu20*dxodu12) + dxodu02*(dxodu10*dxodu21 - dxodu20*dxodu11);

            bool DDD = false;
            bool DDD2 = false;
       /*     if (ccc % 200 == 0) {
               DDD = DDD2 = true;
            }*/
             //if (det < 0) cout<<"Negative det"<<endl;
            //cout<<det<<endl;


            if (config.forceMethod == FORCE_MIXED_CI) {
               MATRIX3 mat(dxodu00, dxodu01, dxodu02,
                  dxodu10, dxodu11, dxodu12,
                  dxodu20, dxodu21, dxodu22);
               mat = mat.TimesTranspose(theRot);
               MATRIX3 vmat = MATRIX3(dvodu00, dvodu01, dvodu02, dvodu10, dvodu11, dvodu12, dvodu20, dvodu21, dvodu22).TimesTranspose(theRot);
               VEC3 f1,f2,f3;
               if (det > config.mixDetThreshold) {
   //               countCauchy++;
                  if (config.dampPhysical) {
                     
                     ComputeForceCauchy(mat, theRot, t, f1, f2, f3, &vmat);   
                  } else {
                     ComputeForceCauchy(mat, theRot, t, f1, f2, f3, NULL);   
                  }
               } else
               if (det < 0) {
                  if (config.dampPhysical) {
                     ComputeForceIrving(mat, theRot, t, f1, f2, f3, &vmat);   
                  } else {
                     ComputeForceIrving(mat, theRot, t, f1, f2, f3, NULL);   
                  }
               } else {
                  // Blend
                  VEC3 f1i, f2i, f3i;
                  //ComputeForceIrving(mat, theRot, t, f1, f2, f3);   
                  MATRIX3 D(dxodu00, dxodu01, dxodu02,
                     dxodu10, dxodu11, dxodu12,
                     dxodu20, dxodu21, dxodu22);
                  D = D.TimesTranspose(theRot);

                  if (config.dampPhysical) {
                     ComputeForceCauchy(D, theRot, t, f1, f2, f3, &vmat);   
                     ComputeForceIrving(mat, theRot, t, f1i, f2i, f3i, &vmat);                 
                  } else {
                     ComputeForceCauchy(D, theRot, t, f1, f2, f3, NULL);   
                     ComputeForceIrving(mat, theRot, t, f1i, f2i, f3i, NULL);   
                  }
                  /*ComputeForceCauchy(mat, theRot, t, f1i, f2i, f3i);   */
                  real fC = (det)*config.imixDetThreshold, fi = 1.0 - fC;
                  f1 = fC*f1 + fi*f1i;
                  f2 = fC*f2 + fi*f2i;
                  f3 = fC*f3 + fi*f3i;
               }

               #ifdef USE_FORCE_TET
                  forceTets[t].f1 = f1;
                  forceTets[t].f2 = f2;
                  forceTets[t].f3 = f3;
               #else
                  force[tet[0]] += (-f1 - f2 -f3);
                  force[tet[1]] += f1;
                  force[tet[2]] += f2;
                  force[tet[3]] += f3;       
               #endif
            } else
            if (config.forceMethod == FORCE_CAUCHY) {
               
               //cout<<"Irving"<<endl;


               // Use Irving et. al 2004 to calculate force instead, for inverted elements
               /*
               MATRIX3 mat(dxodu00, 0.5f*(dxodu01 + dxodu10), 0.5f*(dxodu02 + dxodu20),
                                      0.5f*(dxodu01 + dxodu10), dxodu11, 0.5f*(dxodu12 + dxodu21),
                                      0.5f*(dxodu02 + dxodu20), 0.5f*(dxodu12 + dxodu21), dxodu22);

               MATRIX3 &D = mat;
               real lambdatracem3 = (D[0][0] + D[1][1] + D[2][2]) * lambda;
               D[0][0] = 2*mu*(D[0][0]) + lambdatracem3;
               D[0][1] *= 2*mu;
               D[0][2] *= 2*mu;
               D[1][0] *= 2*mu;
               D[1][1] = 2*mu*(D[1][1]) + lambdatracem3;
               D[1][2] *= 2*mu;
               D[2][0] *= 2*mu;
               D[2][1] *= 2*mu;
               D[2][2] = 2*mu*(D[2][2]) + lambdatracem3;

      */

               VEC3 f1,f2,f3;
               MATRIX3 D(dxodu00, dxodu01, dxodu02,
                  dxodu10, dxodu11, dxodu12,
                  dxodu20, dxodu21, dxodu22);
               D = D.TimesTranspose(theRot);
               MATRIX3 vmat = MATRIX3(dvodu00, dvodu01, dvodu02, dvodu10, dvodu11, dvodu12, dvodu20, dvodu21, dvodu22).TimesTranspose(theRot);
               if (config.dampPhysical) {
                  ComputeForceCauchy(D, theRot, t, f1, f2, f3, &vmat);
               } else {
                  ComputeForceCauchy(D, theRot, t, f1, f2, f3, NULL);
               }
               #ifdef USE_FORCE_TET
                  forceTets[t].f1 = f1;
                  forceTets[t].f2 = f2;
                  forceTets[t].f3 = f3;
               #else
                  force[tet[0]] += (-f1 - f2 -f3);
                  force[tet[1]] += f1;
                  force[tet[2]] += f2;
                  force[tet[3]] += f3;       
               #endif


               #ifdef ONE_TET
                  forceList.push_back(f3);
               #endif

            } else 
            if ((config.forceMethod == FORCE_IRVING) || ((config.forceMethod == FORCE_MIXED_GI) && (det < 0))) {
               //cout<<"Irving"<<endl;
               
               
               // Use Irving et. al 2004 to calculate force instead, for inverted elements
               MATRIX3 mat(dxodu00, dxodu01, dxodu02,
                                      dxodu10, dxodu11, dxodu12,
                                      dxodu20, dxodu21, dxodu22);

               VEC3 f1,f2,f3;

               if (config.dampPhysical) {

                  MATRIX3 vmat(dvodu00, dvodu01, dvodu02,
                                          dvodu10, dvodu11, dvodu12,
                                          dvodu20, dvodu21, dvodu22);


                  ComputeForceIrving(mat, theRot, t, f1, f2, f3, &vmat);
               } else {
                  ComputeForceIrving(mat, theRot, t, f1, f2, f3, NULL);
               }


               #ifdef USE_FORCE_TET
                  forceTets[t].f1 = f1;
                  forceTets[t].f2 = f2;
                  forceTets[t].f3 = f3;
               #else
                  force[tet[0]] += (-f1 - f2 -f3);
                  force[tet[1]] += f1;
                  force[tet[2]] += f2;
                  force[tet[3]] += f3;       
               #endif

               #ifdef ONE_TET
                  forceList.push_back(f3);
               #endif
      /*         if (len(f1) > maxForceMag) maxForceMag = len(f1);
               if (len(f2) > maxForceMag) maxForceMag = len(f2);
               if (len(f3) > maxForceMag) maxForceMag = len(f3);
               if (len(f1+f2+f3) > maxForceMag) maxForceMag = len(f1+f2+f3);

               if (DDD2) cout<<"f1: "<<f1[0]<<" "<<f1[1]<<" "<<f1[2]<<endl;
               if (DDD2) cout<<"f2: "<<f2[0]<<" "<<f2[1]<<" "<<f2[2]<<endl;
               if (DDD2) cout<<"f3: "<<f3[0]<<" "<<f3[1]<<" "<<f3[2]<<endl;
      */
               /*
               // Apply an artificial force to revert the invertion
               const int ind[4][3] = {
                  {1,3,2}, 
                  {0,2,3},
                  {0,3,1},
                  {0,1,2}};
               int mini;
               real mindis = 1e5;
               VEC3 mindir;
               for (int i = 0; i < 4; i++) {
                  VEC3 nv;
                  VEC3 v0 = worldPos[tet[ind[i][1]]]-worldPos[tet[ind[i][0]]],
                      v1 = worldPos[tet[ind[i][2]]]-worldPos[tet[ind[i][0]]];
                  nv = cross(v0, v1);
                  nv.Normalise();
                  real dis = dot(nv, worldPos[tet[i]] - worldPos[tet[ind[i][0]]]);
                  if (dis < mindis) {
                     mindis = dis;
                     mindir = nv;
                     mini = i;
                  }
               }
               force[tet[mini]] -= mindir*mindis*1000;

               //cout<<"Negative det detected!"<<endl;
               */
            } else {
               //cout<<"Green"<<endl;

               //const real CCphi = 100.0f, psi = 100.0f;
               // Green strain         
               strain00_m2 = ((dxodu00*dxodu00 + dxodu01*dxodu01 + dxodu02*dxodu02)-1.0); 
               strain01_m2 = ((dxodu00*dxodu10 + dxodu01*dxodu11 + dxodu02*dxodu12)); 
               strain02_m2 = ((dxodu00*dxodu20 + dxodu01*dxodu21 + dxodu02*dxodu22)); 
               strain11_m2 = ((dxodu10*dxodu10 + dxodu11*dxodu11 + dxodu12*dxodu12)-1.0); 
               strain12_m2 = ((dxodu10*dxodu20 + dxodu11*dxodu21 + dxodu12*dxodu22)); 
               strain22_m2 = ((dxodu20*dxodu20 + dxodu21*dxodu21 + dxodu22*dxodu22)-1.0); 

               // Stress
               real trace = 0.5*(strain00_m2+strain11_m2+strain22_m2);
               real llt = trace * lambda;
               if (config.dampPhysical) {
                  // Strain rate
                  vstrain00 = 2.0f*(dxodu00*dvodu00 + dxodu10*dvodu10  + dxodu20*dvodu20);

                  vstrain01 = (dxodu00*dvodu01 + dxodu10*dvodu11  + dxodu20*dvodu21) +
                              (dxodu01*dvodu00 + dxodu11*dvodu10  + dxodu21*dvodu20);

                  vstrain02 = (dxodu00*dvodu02 + dxodu10*dvodu12  + dxodu20*dvodu22) +
                              (dxodu02*dvodu00 + dxodu12*dvodu10  + dxodu22*dvodu20);

                  vstrain11 = 2.0f*(dxodu01*dvodu01 + dxodu11*dvodu11  + dxodu21*dvodu21);

                  vstrain12 = (dxodu01*dvodu02 + dxodu11*dvodu12  + dxodu21*dvodu22) +
                              (dxodu02*dvodu01 + dxodu12*dvodu11  + dxodu22*dvodu21);

                  vstrain22 = 2.0f*(dxodu02*dvodu02 + dxodu12*dvodu12  + dxodu22*dvodu22);
                     


                  real vtrace = vstrain00 + vstrain11 + vstrain22;
                  real vtm = psi * vtrace;
                  
         	
                  stress00 = mu*strain00_m2 + llt + twoPhi*vstrain00 + vtm;
                  stress01 = mu*strain01_m2 + twoPhi*vstrain01;
                  stress02 = mu*strain02_m2 + twoPhi*vstrain02;

                  stress11 = mu*strain11_m2 + llt + twoPhi*vstrain11 + vtm;
                  stress12 = mu*strain12_m2 + twoPhi*vstrain12;

                  stress22 = mu*strain22_m2 + llt + twoPhi*vstrain22 + vtm;
               } else {
                  stress00 = mu*strain00_m2 + llt;
                  stress01 = mu*strain01_m2;
                  stress02 = mu*strain02_m2;

                  stress11 = mu*strain11_m2 + llt;
                  stress12 = mu*strain12_m2;

                  stress22 = mu*strain22_m2 + llt;
               }

	            // Compute force

         /*
               VEC3 f1(0,0,0),f2(0,0,0),f3(0,0,0);
	            f1 =             mhvol * (wb0 * (beta_0_4*stress00 + beta_1_4_p_0_5*stress01 + beta_2_4_p_0_6*stress02 + 
                                               beta_1_5*stress11 + beta_2_5_p_1_6*stress12 +
                                               beta_2_6*stress22)  + 
                                         wb1 * (beta_4_4*stress00 + two_beta_4_5*stress01 + two_beta_4_6*stress02 + 
                                               beta_5_5*stress11 + two_beta_5_6*stress12 +
                                               beta_6_6*stress22)  +
                                         wb2 * (beta_4_9*stress01 + beta_4_10*stress02 + 
                                               beta_5_9*stress11 + beta_5_10_p_6_9*stress12 +
                                               beta_6_10*stress22)  +
                                         wb3 * (beta_4_14*stress02 + 
                                               beta_5_14*stress12 +
                                               beta_6_14*stress22));
                                         

	            f2 =             mhvol * (wb0 * (
                                               beta_9_0*stress01 + beta_9_1*stress11 + beta_9_2_p_10_1*stress12 +
                                               beta_10_0*stress02 + beta_10_2*stress22)  + 
                                         wb1 * (
                                               beta_9_4*stress01 + beta_9_5*stress11 + beta_9_6_p_10_5*stress12 +
                                               beta_10_4*stress02 + beta_10_6*stress22)  +
                                         wb2 * ( 
                                               beta_9_9*stress11 + 2*beta_9_10*stress12 +
                                               beta_10_10*stress22)  +
                                         wb3 * (
                                               beta_9_14*stress12 +
                                               beta_10_14*stress22));

	            f3 =              mhvol * (wb0 * (
                                               
                                               beta_14_0*stress02 + beta_14_1*stress12 + beta_14_2*stress22)  + 
                                          wb1 * ( 
                                               
                                               beta_14_4*stress02 + beta_14_5*stress12 + beta_14_6*stress22)  +
                                          wb2 * (                                      
                                               beta_14_9*stress12 + beta_14_10*stress22)  +
                                          wb3 * (                                      
                                               beta_14_14*stress22));
         */
	            VEC3 f1(wb0, (beta_0_4*stress00 + beta_1_4_p_0_5*stress01 + beta_2_4_p_0_6*stress02 + 
                                               beta_1_5*stress11 + beta_2_5_p_1_6*stress12 +
                                               beta_2_6*stress22));
               f1.Mad(wb1, (beta_4_4*stress00 + two_beta_4_5*stress01 + two_beta_4_6*stress02 + 
                                               beta_5_5*stress11 + two_beta_5_6*stress12 +
                                               beta_6_6*stress22));
               f1.Mad(wb2, (beta_4_9*stress01 + beta_4_10*stress02 + 
                                               beta_5_9*stress11 + beta_5_10_p_6_9*stress12 +
                                               beta_6_10*stress22));
               f1.Mad(wb3, (beta_4_14*stress02 + 
                                               beta_5_14*stress12 +
                                               beta_6_14*stress22));
               f1 *= mhvol;
                                         

	            VEC3 f2(wb0, (beta_9_0*stress01 + beta_9_1*stress11 + beta_9_2_p_10_1*stress12 +
                                               beta_10_0*stress02 + beta_10_2*stress22));
               f2.Mad(wb1, (beta_9_4*stress01 + beta_9_5*stress11 + beta_9_6_p_10_5*stress12 +
                                               beta_10_4*stress02 + beta_10_6*stress22));  
               f2.Mad(wb2, (beta_9_9*stress11 + two_beta_9_10*stress12 +
                                               beta_10_10*stress22));
               f2.Mad(wb3, (beta_9_14*stress12 +
                                               beta_10_14*stress22));
               f2 *= mhvol;

	            VEC3 f3(wb0,(beta_14_0*stress02 + beta_14_1*stress12 + beta_14_2*stress22));
               f3.Mad(wb1,(beta_14_4*stress02 + beta_14_5*stress12 + beta_14_6*stress22));
               f3.Mad(wb2,(beta_14_9*stress12 + beta_14_10*stress22));
               f3.Mad(wb3, beta_14_14*stress22);
               f3 *= mhvol;

               if ((config.forceMethod == FORCE_MIXED_GI) && (det < config.mixDetThreshold)) {
                  VEC3 f1i, f2i, f3i;
                  //ComputeForceIrving(mat, theRot, t, f1, f2, f3);   
                  MATRIX3 mat(dxodu00, dxodu01, dxodu02,
                     dxodu10, dxodu11, dxodu12,
                     dxodu20, dxodu21, dxodu22);
                  if (config.dampPhysical) {
                     ComputeForceIrving(mat, theRot, t, f1i, f2i, f3i, &MATRIX3(dvodu00, dvodu01, dvodu02, dvodu10, dvodu11, dvodu12, dvodu20, dvodu21, dvodu22));   
                  } else {
                     ComputeForceIrving(mat, theRot, t, f1i, f2i, f3i, NULL);   
                  }


                  /*ComputeForceCauchy(mat, theRot, t, f1i, f2i, f3i);   */
                  real fg = (det)*config.imixDetThreshold, fi = 1.0 - fg;
                  f1 = fg*f1 + fi*f1i;
                  f2 = fg*f2 + fi*f2i;
                  f3 = fg*f3 + fi*f3i;            
               }
               #ifdef USE_FORCE_TET
                  forceTets[t].f1 = f1;
                  forceTets[t].f2 = f2;
                  forceTets[t].f3 = f3;
               #else
                  force[tet[0]] += (-f1 - f2 -f3);
                  force[tet[1]] += f1;
                  force[tet[2]] += f2;
                  force[tet[3]] += f3;       
               #endif

               #ifdef ONE_TET
                  forceList.push_back(f3);
               #endif
               
      /*         if (len(f1) > maxForceMag) maxForceMag = len(f1);
               if (len(f2) > maxForceMag) maxForceMag = len(f2);
               if (len(f3) > maxForceMag) maxForceMag = len(f3);
               if (len(f1+f2+f3) > maxForceMag) maxForceMag = len(f1+f2+f3);

               if (DDD2) cout<<"f1: "<<f1[0]<<" "<<f1[1]<<" "<<f1[2]<<endl;
               if (DDD2) cout<<"f2: "<<f2[0]<<" "<<f2[1]<<" "<<f2[2]<<endl;
               if (DDD2) cout<<"f3: "<<f3[0]<<" "<<f3[1]<<" "<<f3[2]<<endl;
               */

            }

	      }
      /*   if (config.forceMethod != FORCE_MIXED_CI) {
            cout<<"Count = "<<ccc<<endl;
         } else {
            cout<<"Count = "<<ccc<<" Fraction of Cauchy ="<<((float)countCauchy / numTets)<<endl;
         }
      */

      //   cout<<"Max S mag "<<maxSMag<<endl;
        // cout<<"Max force mag is "<<maxForceMag<<endl;
         //if (maxForceMag > 1e5) {
           // cout<<""<<endl;
        // }
         //if (minDet < 0) {
            //cout<<"Negative det detected!"<<endl;
        // }
         //cout<<minDet<<endl;
         /*
	      for (int t = 0; t < numTets; t++) {
		      CMat4x4 &beta = baryMat[t];
  		      CTet& tet = tet2node[t];
		      real vol = tetVol[t];
		      real mhvol = -0.5*vol;
		      real rhovold20 = rho*vol/20.0f;
            
            VEC3 w0, w1, w2, w3;
            Mul3(rotMat[t],(worldPos[tet[0]]-matPos[tet[0]]), w0);
            Mul3(rotMat[t],(worldPos[tet[1]]-matPos[tet[0]]), w1);
            Mul3(rotMat[t],(worldPos[tet[2]]-matPos[tet[0]]), w2);
            Mul3(rotMat[t],(worldPos[tet[3]]-matPos[tet[0]]), w3);




		      // Find dx/du_i

		      dxodu[0][0] = (w0[0]*beta[0] + w1[0]*beta[4]);
            dxodu[0][1] = (w0[1]*beta[0] + w1[1]*beta[4]);
            dxodu[0][2] = (w0[2]*beta[0] + w1[2]*beta[4]);
	         dxodu[1][0] = (w0[0]*beta[1] + w1[0]*beta[5] + w2[0]*beta[9]);
            dxodu[1][1] = (w0[1]*beta[1] + w1[1]*beta[5] + w2[1]*beta[9]);
            dxodu[1][2] = (w0[2]*beta[1] + w1[2]*beta[5] + w2[2]*beta[9]);
	         dxodu[2][0] = (w0[0]*beta[2] + w1[0]*beta[6] + w2[0]*beta[10] + w3[0]*beta[14]);
            dxodu[2][1] = (w0[1]*beta[2] + w1[1]*beta[6] + w2[1]*beta[10] + w3[1]*beta[14]);
            dxodu[2][2] = (w0[2]*beta[2] + w1[2]*beta[6] + w2[2]*beta[10] + w3[2]*beta[14]);


		      // Green strain
            strain[0][0] = 0.5*((dxodu[0][0]*dxodu[0][0] + dxodu[0][1]*dxodu[0][1] + dxodu[0][2]*dxodu[0][2])-1.0); 
            strain[0][1] = 0.5*((dxodu[0][0]*dxodu[1][0] + dxodu[0][1]*dxodu[1][1] + dxodu[0][2]*dxodu[1][2])); 
            strain[0][2] = 0.5*((dxodu[0][0]*dxodu[2][0] + dxodu[0][1]*dxodu[2][1] + dxodu[0][2]*dxodu[2][2])); 
            strain[1][0] = 0.5*((dxodu[1][0]*dxodu[0][0] + dxodu[1][1]*dxodu[0][1] + dxodu[1][2]*dxodu[0][2])); 
            strain[1][1] = 0.5*((dxodu[1][0]*dxodu[1][0] + dxodu[1][1]*dxodu[1][1] + dxodu[1][2]*dxodu[1][2])-1.0); 
            strain[1][2] = 0.5*((dxodu[1][0]*dxodu[2][0] + dxodu[1][1]*dxodu[2][1] + dxodu[1][2]*dxodu[2][2])); 
            strain[2][0] = 0.5*((dxodu[2][0]*dxodu[0][0] + dxodu[2][1]*dxodu[0][1] + dxodu[2][2]*dxodu[0][2])); 
            strain[2][1] = 0.5*((dxodu[2][0]*dxodu[1][0] + dxodu[2][1]*dxodu[1][1] + dxodu[2][2]*dxodu[1][2])); 
            strain[2][2] = 0.5*((dxodu[2][0]*dxodu[2][0] + dxodu[2][1]*dxodu[2][1] + dxodu[2][2]*dxodu[2][2])-1.0); 

		      // Stress
		      real trace = strain[0][0]+strain[1][1]+strain[2][2];
	         stress[0][0] = 2*mu*strain[0][0] + lambda*trace;
	         stress[0][1] = 2*mu*strain[0][1];
	         stress[0][2] = 2*mu*strain[0][2];

	         stress[1][0] = 2*mu*strain[1][0];
	         stress[1][1] = 2*mu*strain[1][1] + lambda*trace;
	         stress[1][2] = 2*mu*strain[1][2];

	         stress[2][0] = 2*mu*strain[2][0];
	         stress[2][1] = 2*mu*strain[2][1];
	         stress[2][2] = 2*mu*strain[2][2] + lambda*trace;
      		

		      // Compute force


            VEC3 f0,f1,f2,f3;
		      Mul3t(rotMat[t], mhvol * (w0 * (beta[0]*(beta[0]*stress[0][0] + beta[1]*stress[0][1] + beta[2]*stress[0][2]) + 
                                            beta[1]*(beta[0]*stress[1][0] + beta[1]*stress[1][1] + beta[2]*stress[1][2]) +
                                            beta[2]*(beta[0]*stress[2][0] + beta[1]*stress[2][1] + beta[2]*stress[2][2]))  + 
                                      w1 * (beta[0]*(beta[4]*stress[0][0] + beta[5]*stress[0][1] + beta[6]*stress[0][2]) + 
                                            beta[1]*(beta[4]*stress[1][0] + beta[5]*stress[1][1] + beta[6]*stress[1][2]) +
                                            beta[2]*(beta[4]*stress[2][0] + beta[5]*stress[2][1] + beta[6]*stress[2][2]))  +
                                      w2 * (beta[0]*(beta[9]*stress[0][1] + beta[10]*stress[0][2]) + 
                                            beta[1]*(beta[9]*stress[1][1] + beta[10]*stress[1][2]) +
                                            beta[2]*(beta[9]*stress[2][1] + beta[10]*stress[2][2]))  +
                                      w3 * (beta[0]*(beta[14]*stress[0][2]) + 
                                            beta[1]*(beta[14]*stress[1][2]) +
                                            beta[2]*(beta[14]*stress[2][2])))
                                      ,f0);

		      Mul3t(rotMat[t], mhvol * (w0 * (beta[4]*(beta[0]*stress[0][0] + beta[1]*stress[0][1] + beta[2]*stress[0][2]) + 
                                            beta[5]*(beta[0]*stress[1][0] + beta[1]*stress[1][1] + beta[2]*stress[1][2]) +
                                            beta[6]*(beta[0]*stress[2][0] + beta[1]*stress[2][1] + beta[2]*stress[2][2]))  + 
                                      w1 * (beta[4]*(beta[4]*stress[0][0] + beta[5]*stress[0][1] + beta[6]*stress[0][2]) + 
                                            beta[5]*(beta[4]*stress[1][0] + beta[5]*stress[1][1] + beta[6]*stress[1][2]) +
                                            beta[6]*(beta[4]*stress[2][0] + beta[5]*stress[2][1] + beta[6]*stress[2][2]))  +
                                      w2 * (beta[4]*(beta[9]*stress[0][1] + beta[10]*stress[0][2]) + 
                                            beta[5]*(beta[9]*stress[1][1] + beta[10]*stress[1][2]) +
                                            beta[6]*(beta[9]*stress[2][1] + beta[10]*stress[2][2]))  +
                                      w3 * (beta[4]*(beta[14]*stress[0][2]) + 
                                            beta[5]*(beta[14]*stress[1][2]) +
                                            beta[6]*(beta[14]*stress[2][2])))
                                      ,f1);

		      Mul3t(rotMat[t], mhvol * (w0 * (
                                            beta[9]*(beta[0]*stress[1][0] + beta[1]*stress[1][1] + beta[2]*stress[1][2]) +
                                            beta[10]*(beta[0]*stress[2][0] + beta[1]*stress[2][1] + beta[2]*stress[2][2]))  + 
                                      w1 * (
                                            beta[9]*(beta[4]*stress[1][0] + beta[5]*stress[1][1] + beta[6]*stress[1][2]) +
                                            beta[10]*(beta[4]*stress[2][0] + beta[5]*stress[2][1] + beta[6]*stress[2][2]))  +
                                      w2 * ( 
                                            beta[9]*(beta[9]*stress[1][1] + beta[10]*stress[1][2]) +
                                            beta[10]*(beta[9]*stress[2][1] + beta[10]*stress[2][2]))  +
                                      w3 * (
                                            beta[9]*(beta[14]*stress[1][2]) +
                                            beta[10]*(beta[14]*stress[2][2])))
                                      ,f2);

		      Mul3t(rotMat[t], mhvol * (w0 * (
                                            
                                            beta[14]*(beta[0]*stress[2][0] + beta[1]*stress[2][1] + beta[2]*stress[2][2]))  + 
                                      w1 * ( 
                                            
                                            beta[14]*(beta[4]*stress[2][0] + beta[5]*stress[2][1] + beta[6]*stress[2][2]))  +
                                      w2 * (
                                            
                                            beta[14]*(beta[9]*stress[2][1] + beta[10]*stress[2][2]))  +
                                      w3 * (
                                            
                                            beta[14]*(beta[14]*stress[2][2])))
                                      ,f3);
            force[tet[0]] += f0;
            force[tet[1]] += f1;
            force[tet[2]] += f2;
            force[tet[3]] += f3;
	      }
         */
      }
      #ifdef USE_FORCE_TET
         for (int t = 0; t < numTets; t++) {
            CTet& tet = tet2node[t];
            force[tet[0]] -= (forceTets[t].f1 + forceTets[t].f2 + forceTets[t].f3);
            force[tet[1]] += forceTets[t].f1;
            force[tet[2]] += forceTets[t].f2;
            force[tet[3]] += forceTets[t].f3;

            real mmm = max(max(max(forceTets[t].f1.Length(),forceTets[t].f2.Length()),forceTets[t].f3.Length()), (forceTets[t].f1 + forceTets[t].f2 + forceTets[t].f3).Length());
            //cout<<t<<" : "<<mmm<<endl;
         }
      #endif
      double putMatTime = timer.Stop();
      sumTime += putMatTime;
   }

   // Add external force
   int numExt = extForce.size();
   for (int i = 0; i < numExt; i++) {
      //cout<<"Force at "<<extForce[i].nodeNum<<" was "<<force[extForce[i].nodeNum]<<" now "<<extForce[i].force<<endl;
      force[extForce[i].nodeNum] += extForce[i].force;
   }

   for (int i = 0; i < numNodes; i++) {
      force[i] += mass[i] * config.gravity;
   }

/*   char st[30];
   static int xxc = 0;
   
   if (xxc % 50 == 0) {
      sprintf(st, "kk_%d.m", xxc);
      WriteMFile(CCoorMatrix<real>(*K), st);
   }
   xxc++;*/
}


void CFEMMesh::ComputeAcceleration(real dt) {
   ComputeForce(dt);
   // Compute acceleration
   for (int i = 0; i < numNodes; i++) {
      acceleration[i] = force[i] / mass[i];
   }

}
void CFEMMesh::AdvanceTimeForExternalForce(real dt) {
   // Add external force
   int numExt = extForce.size();
   for (int i = 0; i < numExt; i++) {
      //cout<<"Force at "<<extForce[i].nodeNum<<" was "<<force[extForce[i].nodeNum]<<" now "<<extForce[i].force<<endl;
      extForce[i].duration -= dt;
      if (extForce[i].duration <= 1e-10) {
         extForce[i] = extForce[numExt - 1];
         extForce.pop_back();
         numExt--;
         i--;
      }
   }

}



real CFEMMesh::UpdateVelocityAndPosition(real dt) {

   dt = integrator->TimeStepping(dt);
   AdvanceTimeForExternalForce(dt);
   return dt;

   
}


real CFEMMesh::Simulate(real dt) {
   dt = UpdateVelocityAndPosition(dt);	
   return dt;
}


void CFEMMesh::FindUniqueEdges(vector<CEdge>& edges, vector<CEdge>& uedges) {
   sort(edges.begin(), edges.end());
   uedges.clear();
   uedges.push_back(edges[0]);
   for (int i = 1; i < edges.size(); i++) {
      if (!(edges[i-1] == edges[i])) {
         uedges.push_back(edges[i]);
      }
   }
}

void CFEMMesh::FindEdges() {
   numTets = tet2node.size();
   vector<CEdge> edges;

   // Find tet edges
   int* ptet = tet2node[0].id;
   for (int i = 0; i < numTets; i++) {
      edges.push_back(CEdge(ptet[0], ptet[1]));
      edges.push_back(CEdge(ptet[0], ptet[2]));
      edges.push_back(CEdge(ptet[0], ptet[3]));
      edges.push_back(CEdge(ptet[1], ptet[2]));
      edges.push_back(CEdge(ptet[1], ptet[3]));
      edges.push_back(CEdge(ptet[2], ptet[3]));
      ptet+=4;
   }

   FindUniqueEdges(edges, tetEdges);

   // Find tri edges
/*   edges.clear();
   int* ptri = tri2node[0].id;
   for (int i = 0; i < numTris; i++) {
      edges.push_back(CEdge(ptri[0], ptri[1]));
      edges.push_back(CEdge(ptri[0], ptri[2]));
      edges.push_back(CEdge(ptri[1], ptri[2]));
      ptri+=3;
   }
   FindUniqueEdges(edges, triEdges);*/

}

void CFEMMesh::RenderEdges(vector<CEdge>& edges, VEC3* pos) {
   #ifndef NO_GRAPHICS

   int numEdges = edges.size();
   glBegin(GL_LINES);
	for (int i = 0; i < numEdges; i++) {
		
      glVertex3f(pos[edges[i].indL][0], pos[edges[i].indL][1], pos[edges[i].indL][2]);
		glVertex3f(pos[edges[i].indH][0], pos[edges[i].indH][1], pos[edges[i].indH][2]);
	
	}
	glEnd();
   #endif
}


void CFEMMesh::GenRotMat(const VEC3& v0, const VEC3& v1, const VEC3& v2, MATRIX3& mat) {
   VEC3 b0 = v0 + v1;
   b0.Normalize();
   VEC3 b2 = v2;
   b2.Normalize();
   VEC3 b1 = b2.Cross(b0);
   b1.Normalize();
   b2 = b0.Cross(b1);
   mat(0,0) = b0[0];
   mat(1,0) = b0[1];
   mat(2,0) = b0[2];

   mat(0,1) = b1[0];
   mat(1,1) = b1[1];
   mat(2,1) = b1[2];

   mat(0,2) = b2[0];
   mat(1,2) = b2[1];
   mat(2,2) = b2[2];
}
